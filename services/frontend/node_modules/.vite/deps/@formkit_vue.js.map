{
  "version": 3,
  "sources": ["../../@formkit/utils/dist/index.mjs", "../../@formkit/core/dist/index.mjs", "../../@formkit/inputs/dist/index.mjs", "../../@formkit/rules/dist/index.mjs", "../../@formkit/observer/dist/index.mjs", "../../@formkit/validation/dist/index.mjs", "../../@formkit/i18n/dist/index.mjs", "../../@formkit/themes/dist/index.mjs", "../../@formkit/dev/dist/index.mjs", "../../@formkit/vue/dist/index.mjs"],
  "sourcesContent": ["/**\n * Generates a random string.\n * @returns string\n * @public\n */\nfunction token() {\n    return Math.random().toString(36).substring(2, 15);\n}\n/**\n * Creates a new set of the specified type and uses the values from an Array or\n * an existing Set.\n * @param items -\n * @returns Set\n * @public\n */\nfunction setify(items) {\n    return items instanceof Set ? items : new Set(items);\n}\n/**\n * Given 2 arrays, return them as a combined array with no duplicates.\n * @param arr1 -\n * @param arr2 -\n * @returns any[]\n * @public\n */\nfunction dedupe(arr1, arr2) {\n    const original = arr1 instanceof Set ? arr1 : new Set(arr1);\n    if (arr2)\n        arr2.forEach((item) => original.add(item));\n    return [...original];\n}\n/**\n * Checks if the given property exists on the given object.\n * @param obj -\n * @param property -\n * @public\n */\nfunction has(obj, property) {\n    return Object.prototype.hasOwnProperty.call(obj, property);\n}\n/**\n * Compare two values for equality optionally at depth.\n * @param valA - Any type of input\n * @param valB - Any type of output\n * @param deep - Indicate if we should recurse into the object\n * @param explicit - Explicit keys\n * @returns boolean\n * @public\n */\nfunction eq(valA, // eslint-disable-line\nvalB, // eslint-disable-line\ndeep = true, explicit = ['__key']) {\n    if (valA === valB)\n        return true;\n    if (typeof valB === 'object' && typeof valA === 'object') {\n        if (valA instanceof Map)\n            return false;\n        if (valA instanceof Set)\n            return false;\n        if (valA instanceof Date)\n            return false;\n        if (valA === null || valB === null)\n            return false;\n        if (Object.keys(valA).length !== Object.keys(valB).length)\n            return false;\n        for (const k of explicit) {\n            if ((k in valA || k in valB) && valA[k] !== valB[k])\n                return false;\n        }\n        for (const key in valA) {\n            if (!(key in valB))\n                return false;\n            if (valA[key] !== valB[key] && !deep)\n                return false;\n            if (deep && !eq(valA[key], valB[key], deep, explicit))\n                return false;\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if a value is empty or not.\n * @param value - any type of value that could be returned by an input.\n * @public\n */\nfunction empty(value // eslint-disable-line\n) {\n    const type = typeof value;\n    if (type === 'number')\n        return false;\n    if (value === undefined)\n        return true;\n    if (type === 'string') {\n        return value === '';\n    }\n    if (type === 'object') {\n        if (value === null)\n            return true;\n        for (const _i in value)\n            return false;\n        if (value instanceof RegExp)\n            return false;\n        if (value instanceof Date)\n            return false;\n        return true;\n    }\n    return false;\n}\n/**\n * Escape a string for use in regular expressions.\n * @param string - The string to escape.\n * @public\n */\nfunction escapeExp(string) {\n    // $& means the whole matched string\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n/**\n * Given a string format (date) return a regex to match against.\n * @param format - The format of the string\n * @returns\n * @public\n */\nfunction regexForFormat(format) {\n    const escaped = `^${escapeExp(format)}$`;\n    const formats = {\n        MM: '(0[1-9]|1[012])',\n        M: '([1-9]|1[012])',\n        DD: '([012][0-9]|3[01])',\n        D: '([012]?[0-9]|3[01])',\n        YYYY: '\\\\d{4}',\n        YY: '\\\\d{2}',\n    };\n    const tokens = Object.keys(formats);\n    return new RegExp(tokens.reduce((regex, format) => {\n        return regex.replace(format, formats[format]);\n    }, escaped));\n}\n/**\n * Given a FormKit input type\n * @param type - Any FormKit input type\n * @public\n */\nfunction nodeType(type) {\n    const t = type.toLowerCase();\n    if (t === 'list')\n        return 'list';\n    if (t === 'group')\n        return 'group';\n    return 'input';\n}\n/**\n * Determines if an object is an object or not.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isRecord(o) {\n    return Object.prototype.toString.call(o) === '[object Object]';\n}\n/**\n * Checks if an object is a simple array or record.\n * @param o - A value to check\n * @returns\n * @public\n */\nfunction isObject(o) {\n    return isRecord(o) || Array.isArray(o);\n}\n/**\n * Attempts to determine if an object is a plain object. Mostly lifted from\n * is-plain-object: https://github.com/jonschlinkert/is-plain-object\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isPojo(o) {\n    if (isRecord(o) === false)\n        return false;\n    if (o.__FKNode__ || o.__POJO__ === false)\n        return false;\n    const ctor = o.constructor;\n    if (ctor === undefined)\n        return true;\n    const prot = ctor.prototype;\n    if (isRecord(prot) === false)\n        return false;\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Recursively merge data from additional into original returning a new object.\n * @param original - An object to extend\n * @param additional - An object to modify the original object with.\n * @param arrays - By default replaces arrays, but can also append to them.\n * @param ignoreUndefined - when true it treats undefined values as if they dont exist\n * @public\n */\nfunction extend(original, additional, extendArrays = false, ignoreUndefined = false) {\n    if (additional === null)\n        return null;\n    const merged = {};\n    if (typeof additional === 'string')\n        return additional;\n    for (const key in original) {\n        if (has(additional, key) &&\n            (additional[key] !== undefined || !ignoreUndefined)) {\n            if (extendArrays &&\n                Array.isArray(original[key]) &&\n                Array.isArray(additional[key])) {\n                merged[key] = original[key].concat(additional[key]);\n                continue;\n            }\n            if (additional[key] === undefined) {\n                continue;\n            }\n            if (isPojo(original[key]) && isPojo(additional[key])) {\n                merged[key] = extend(original[key], additional[key], extendArrays, ignoreUndefined);\n            }\n            else {\n                merged[key] = additional[key];\n            }\n        }\n        else {\n            merged[key] = original[key];\n        }\n    }\n    for (const key in additional) {\n        if (!has(merged, key) && additional[key] !== undefined) {\n            merged[key] = additional[key];\n        }\n    }\n    return merged;\n}\n/**\n * Determine if the given string is fully quoted. Examples:\n * hello - false\n * \"hello\" - true\n * 'world' - true\n * \"hello\"==\"world\" - false\n * \"hello'this'\" - false\n * \"hello\"'there' - false\n * \"hello\"\"there\" - false\n * 'hello === world' - true\n * @param str - A string to check.\n * @public\n */\nfunction isQuotedString(str) {\n    // quickly return false if the value is note quoted\n    if (str[0] !== '\"' && str[0] !== \"'\")\n        return false;\n    if (str[0] !== str[str.length - 1])\n        return false;\n    const quoteType = str[0];\n    for (let p = 1; p < str.length; p++) {\n        if (str[p] === quoteType &&\n            (p === 1 || str[p - 1] !== '\\\\') &&\n            p !== str.length - 1) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove extra escape characters.\n * @param str - A string to remove escape characters from.\n * @public\n */\nfunction rmEscapes(str) {\n    if (!str.length)\n        return '';\n    let clean = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char !== '\\\\' || lastChar === '\\\\') {\n            clean += char;\n        }\n        lastChar = char;\n    }\n    return clean;\n}\n/**\n * Performs a recursive Object.assign like operation.\n * @param a - An object to be extended by object b\n * @param b - An object to copy values from\n * @public\n */\nfunction assignDeep(a, b) {\n    for (const key in a) {\n        if (has(b, key) &&\n            a[key] !== b[key] &&\n            !(isPojo(a[key]) && isPojo(b[key]))) {\n            a[key] = b[key];\n        }\n        else if (isPojo(a[key]) && isPojo(b[key])) {\n            assignDeep(a[key], b[key]);\n        }\n    }\n    for (const key in b) {\n        if (!has(a, key)) {\n            a[key] = b[key];\n        }\n    }\n    return a;\n}\n/**\n * Filters out values from an object that should not be considered \"props\" of\n * a core node, like \"value\" and \"name\".\n * @param attrs - An object to extract core node config from.\n * @public\n */\nfunction nodeProps(...sets) {\n    return sets.reduce((valid, props) => {\n        const { value, name, modelValue, config, plugins, ...validProps } = props; // eslint-disable-line\n        return Object.assign(valid, validProps);\n    }, {});\n}\n/**\n * Parse a string for comma-separated arguments\n * @param str - A string to parse\n * @public\n */\nfunction parseArgs(str) {\n    const args = [];\n    let arg = '';\n    let depth = 0;\n    let quote = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char === quote && lastChar !== '\\\\') {\n            quote = '';\n        }\n        else if ((char === \"'\" || char === '\"') && !quote && lastChar !== '\\\\') {\n            quote = char;\n        }\n        else if (char === '(' && !quote) {\n            depth++;\n        }\n        else if (char === ')' && !quote) {\n            depth--;\n        }\n        if (char === ',' && !quote && depth === 0) {\n            args.push(arg);\n            arg = '';\n        }\n        else if (char !== ' ' || quote) {\n            arg += char;\n        }\n        lastChar = char;\n    }\n    if (arg) {\n        args.push(arg);\n    }\n    return args;\n}\n/**\n * Return a new (shallow) object with all properties from a given object\n * that are present in the array.\n * @param obj - An object to clone\n * @param toRemove - An array of keys to remove\n * @public\n */\nfunction except(obj, toRemove) {\n    const clean = {};\n    const exps = toRemove.filter((n) => n instanceof RegExp);\n    const keysToRemove = new Set(toRemove);\n    for (const key in obj) {\n        if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    }\n    return clean;\n}\n/**\n * Extracts a set of keys from a given object. Importantly, this will extract\n * values even if they are not set on the original object they will just have an\n * undefined value.\n * @param obj - An object to extract values from\n * @param include - A set of keys to extract\n * @returns\n * @public\n */\nfunction only(obj, include) {\n    const clean = {};\n    const exps = include.filter((n) => n instanceof RegExp);\n    include.forEach((key) => {\n        if (!(key instanceof RegExp)) {\n            clean[key] = obj[key];\n        }\n    });\n    Object.keys(obj).forEach((key) => {\n        if (exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    });\n    return clean;\n}\n/**\n * This converts kebab-case to camelCase. It ONLY converts from kebab for\n * efficiency stake.\n * @param str - String to convert.\n * @public\n */\nfunction camel(str) {\n    return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());\n}\n/**\n * This converts camel-case to kebab case. It ONLY converts from camel to kebab.\n * @param str - Converts camel to kebab\n * @returns\n * @public\n */\nfunction kebab(str) {\n    return str\n        .replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap) => trail + '-' + cap.toLowerCase())\n        .replace(' ', '-')\n        .toLowerCase();\n}\n/**\n * Very shallowly clones the given object.\n * @param obj - The object to shallow clone\n * @returns\n * @public\n */\nfunction shallowClone(obj, explicit = ['__key', '__init']) {\n    if (obj !== null && typeof obj === 'object') {\n        let returnObject;\n        if (Array.isArray(obj))\n            returnObject = [...obj];\n        else if (isPojo(obj))\n            returnObject = { ...obj };\n        if (returnObject) {\n            applyExplicit(obj, returnObject, explicit);\n            return returnObject;\n        }\n    }\n    return obj;\n}\n/**\n * Perform a recursive clone on a given object. This only intended to be used\n * for simple objects like arrays and pojos.\n * @param obj - Object to clone\n * @public\n */\nfunction clone(obj, explicit = ['__key', '__init']) {\n    if (obj === null ||\n        obj instanceof RegExp ||\n        obj instanceof Date ||\n        obj instanceof Map ||\n        obj instanceof Set ||\n        (typeof File === 'function' && obj instanceof File))\n        return obj;\n    let returnObject;\n    if (Array.isArray(obj)) {\n        returnObject = obj.map((value) => {\n            if (typeof value === 'object')\n                return clone(value, explicit);\n            return value;\n        });\n    }\n    else {\n        returnObject = Object.keys(obj).reduce((newObj, key) => {\n            newObj[key] =\n                typeof obj[key] === 'object'\n                    ? clone(obj[key], explicit)\n                    : obj[key];\n            return newObj;\n        }, {});\n    }\n    for (const key of explicit) {\n        if (key in obj) {\n            Object.defineProperty(returnObject, key, {\n                enumerable: false,\n                value: obj[key],\n            });\n        }\n    }\n    return returnObject;\n}\n/**\n * Clones anything. If the item is scalar, no worries, it passes it back. if it\n * is an object, it performs a (fast/loose) clone operation.\n * @param obj - The object to clone\n * @public\n */\nfunction cloneAny(obj) {\n    return typeof obj === 'object'\n        ? clone(obj)\n        : obj;\n}\n/**\n * Get a specific value via dot notation.\n * @param obj - An object to fetch data from\n * @param addr - An \"address\" in dot notation\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getAt(obj, addr) {\n    if (!obj || typeof obj !== 'object')\n        return null;\n    const segments = addr.split('.');\n    let o = obj;\n    for (const i in segments) {\n        const segment = segments[i];\n        if (has(o, segment)) {\n            o = o[segment];\n        }\n        if (+i === segments.length - 1)\n            return o;\n        if (!o || typeof o !== 'object')\n            return null;\n    }\n    return null;\n}\n/**\n * Determines if the value of a prop that is either present (true) or not\n * present (false). For example the prop disabled should disable\n * by just existing, but what if it is set to the string \"false\" \u2014 then it\n * should not be disabled.\n * @param value - value to be checked\n * @returns\n * @public\n */\nfunction undefine(value) {\n    return value !== undefined && value !== 'false' && value !== false\n        ? true\n        : undefined;\n}\n/**\n * Defines an object as an initial value.\n * @param obj - Object\n * @returns\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nfunction init(obj) {\n    return !Object.isFrozen(obj)\n        ? Object.defineProperty(obj, '__init', {\n            enumerable: false,\n            value: true,\n        })\n        : obj;\n}\n/**\n * Turn any string into a URL/DOM safe string.\n * @public\n */\nfunction slugify(str) {\n    return str\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '')\n        .toLowerCase()\n        .replace(/[^a-z0-9]/g, ' ')\n        .trim()\n        .replace(/\\s+/g, '-');\n}\n/**\n * Spreads an object or an array, otherwise returns the same value.\n * @param obj - Any value, but will spread objects and arrays\n * @public\n */\nfunction spread(obj, explicit = ['__key', '__init']) {\n    if (obj && typeof obj === 'object') {\n        if (obj instanceof RegExp)\n            return obj;\n        if (obj instanceof Date)\n            return obj;\n        let spread;\n        if (Array.isArray(obj)) {\n            spread = [...obj];\n        }\n        else {\n            spread = { ...obj };\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        return applyExplicit(obj, spread, explicit);\n    }\n    return obj;\n}\n/**\n * Apply non enumerable properties to an object.\n * @param obj - The object to apply non-enumerable properties to\n * @param explicit - An array of non-enumerable properties to apply\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction applyExplicit(original, obj, explicit) {\n    for (const key of explicit) {\n        if (key in original) {\n            Object.defineProperty(obj, key, {\n                enumerable: false,\n                value: original[key],\n            });\n        }\n    }\n    return obj;\n}\n\nexport { assignDeep, camel, clone, cloneAny, dedupe, empty, eq, escapeExp, except, extend, getAt, has, init, isObject, isPojo, isQuotedString, isRecord, kebab, nodeProps, nodeType, only, parseArgs, regexForFormat, rmEscapes, setify, shallowClone, slugify, spread, token, undefine };\n", "import { token, slugify, has, cloneAny, init, clone, camel, undefine, eq, kebab, dedupe, parseArgs, getAt, isQuotedString, rmEscapes } from '@formkit/utils';\n\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n * @returns FormKitDispatcher\n */\nfunction createDispatcher() {\n    const middleware = [];\n    let currentIndex = 0;\n    const use = (dispatchable) => middleware.push(dispatchable);\n    const dispatch = (payload) => {\n        const current = middleware[currentIndex];\n        if (typeof current === 'function') {\n            return current(payload, (explicitPayload) => {\n                currentIndex++;\n                return dispatch(explicitPayload === undefined ? payload : explicitPayload);\n            });\n        }\n        currentIndex = 0;\n        return payload;\n    };\n    use.dispatch = dispatch;\n    use.unshift = (dispatchable) => middleware.unshift(dispatchable);\n    use.remove = (dispatchable) => {\n        const index = middleware.indexOf(dispatchable);\n        if (index > -1)\n            middleware.splice(index, 1);\n    };\n    return use;\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n * @returns FormKitEventEmitter\n */\nfunction createEmitter() {\n    const listeners = new Map();\n    const receipts = new Map();\n    let buffer = undefined;\n    const emitter = (node, event) => {\n        if (buffer) {\n            buffer.set(event.name, [node, event]);\n            return;\n        }\n        if (listeners.has(event.name)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            listeners.get(event.name).forEach((wrapper) => {\n                if (event.origin === node || wrapper.modifiers.includes('deep')) {\n                    wrapper.listener(event);\n                }\n            });\n        }\n        if (event.bubble) {\n            node.bubble(event);\n        }\n    };\n    /**\n     * Add an event listener\n     * @param eventName - The name of the event to listen to\n     * @param listener - The callback\n     * @returns string\n     */\n    emitter.on = (eventName, listener) => {\n        const [event, ...modifiers] = eventName.split('.');\n        const receipt = listener.receipt || token();\n        const wrapper = {\n            modifiers,\n            event,\n            listener,\n            receipt,\n        };\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        listeners.has(event)\n            ? listeners.get(event).push(wrapper)\n            : listeners.set(event, [wrapper]);\n        receipts.has(receipt)\n            ? receipts.get(receipt).push(event)\n            : receipts.set(receipt, [event]);\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        return receipt;\n    };\n    /**\n     * Remove an event listener\n     * @param listenerOrReceipt - Either a receipt or the callback function.\n     */\n    emitter.off = (receipt) => {\n        var _a;\n        if (receipts.has(receipt)) {\n            (_a = receipts.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {\n                const eventListeners = listeners.get(event);\n                if (Array.isArray(eventListeners)) {\n                    listeners.set(event, eventListeners.filter((wrapper) => wrapper.receipt !== receipt));\n                }\n            });\n            receipts.delete(receipt);\n        }\n    };\n    /**\n     * Pause emitting values. Any events emitted while paused will not be emitted\n     * but rather \"stored\" \u2014\u00A0and whichever events are emitted last will be output.\n     * For example:\n     * pause()\n     * emit('foo', 1)\n     * emit('foo', 2)\n     * emit('bar', 3)\n     * emit('bar', 4)\n     * play()\n     * // would result in\n     * emit('foo', 2)\n     * emit('bar', 4)\n     * Optionally pauses all children as well.\n     * @param node - A node to pause all children on.\n     */\n    emitter.pause = (node) => {\n        if (!buffer)\n            buffer = new Map();\n        if (node) {\n            node.walk((child) => child._e.pause());\n        }\n    };\n    /**\n     * Release the current event buffer.\n     * @param node - A node to unpause all children on.\n     */\n    emitter.play = (node) => {\n        if (!buffer)\n            return;\n        const events = buffer;\n        buffer = undefined;\n        events.forEach(([node, event]) => emitter(node, event));\n        if (node) {\n            node.walk((child) => child._e.play());\n        }\n    };\n    return emitter;\n}\n/**\n * Emit an event from this node.\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n * @returns FormKitNode\n */\nfunction emit$1(node, context, name, payload, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\nbubble = true) {\n    context._e(node, {\n        payload,\n        name,\n        bubble,\n        origin: node,\n    });\n    return node;\n}\n/**\n * Send an event from the given node up it's ancestor tree.\n * @param node -\n * @param _context -\n * @param event -\n */\nfunction bubble(node, _context, event) {\n    if (isNode(node.parent)) {\n        node.parent._e(node.parent, event);\n    }\n    return node;\n}\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n * @returns FormKitNode\n */\nfunction on(_node, context, name, listener) {\n    return context._e.on(name, listener);\n}\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n * @returns FormKitNode\n */\nfunction off(node, context, receipt) {\n    context._e.off(receipt);\n    return node;\n}\n\n/**\n * FormKit's global error handler.\n * @public\n */\nconst errorHandler = createDispatcher();\n/**\n * The default error handler just sets the error as the message.\n */\nerrorHandler((error, next) => {\n    if (!error.message)\n        error.message = String(`E${error.code}`);\n    return next(error);\n});\n/**\n * FormKit's global warning handler.\n * @public\n */\nconst warningHandler = createDispatcher();\nwarningHandler((warning, next) => {\n    if (!warning.message)\n        warning.message = String(`W${warning.code}`);\n    const result = next(warning);\n    if (console && typeof console.warn === 'function')\n        console.warn(result.message);\n    return result;\n});\n/**\n * Globally emits a warning.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction warn(code, data = {}) {\n    warningHandler.dispatch({ code, data });\n}\n/**\n * Emits an error, generally should result in an exception.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction error(code, data = {}) {\n    throw Error(errorHandler.dispatch({ code, data }).message);\n}\n\n/**\n * Creates a new FormKitMessage object.\n * @param conf - The message configuration\n * @returns FormKitMessage\n * @public\n */\nfunction createMessage(conf, node) {\n    const m = {\n        blocking: false,\n        key: token(),\n        meta: {},\n        type: 'state',\n        visible: true,\n        ...conf,\n    };\n    if (node && m.value && m.meta.localize !== false) {\n        m.value = node.t(m);\n        m.meta.locale = node.config.locale;\n    }\n    return m;\n}\n/**\n * The available traps on the node's store.\n */\nconst storeTraps = {\n    apply: applyMessages,\n    set: setMessage,\n    remove: removeMessage,\n    filter: filterMessages,\n    reduce: reduceMessages,\n    release: releaseBuffer,\n    touch: touchMessages,\n};\n/**\n * Creates a new FormKit message store.\n * @returns FormKitStore\n */\nfunction createStore(_buffer = false) {\n    const messages = {};\n    let node;\n    let buffer = _buffer;\n    let _b = [];\n    const _m = new Map();\n    let _r = undefined;\n    const store = new Proxy(messages, {\n        get(...args) {\n            const [_target, property] = args;\n            if (property === 'buffer')\n                return buffer;\n            if (property === '_b')\n                return _b;\n            if (property === '_m')\n                return _m;\n            if (property === '_r')\n                return _r;\n            if (has(storeTraps, property)) {\n                return storeTraps[property].bind(null, messages, store, node);\n            }\n            return Reflect.get(...args);\n        },\n        set(_t, prop, value) {\n            if (prop === '_n') {\n                node = value;\n                if (_r === '__n')\n                    releaseMissed(node, store);\n                return true;\n            }\n            else if (prop === '_b') {\n                _b = value;\n                return true;\n            }\n            else if (prop === 'buffer') {\n                buffer = value;\n                return true;\n            }\n            else if (prop === '_r') {\n                _r = value;\n                return true;\n            }\n            error(101, node);\n            return false;\n        },\n    });\n    return store;\n}\n/**\n * Adds a new value to a FormKit message bag.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n * @returns FormKitStore\n */\nfunction setMessage(messageStore, store, node, message) {\n    if (store.buffer) {\n        store._b.push([[message]]);\n        return store;\n    }\n    if (messageStore[message.key] !== message) {\n        if (typeof message.value === 'string' && message.meta.localize !== false) {\n            // Expose the value to translation\n            const previous = message.value;\n            message.value = node.t(message);\n            if (message.value !== previous) {\n                message.meta.locale = node.props.locale;\n            }\n        }\n        const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`;\n        messageStore[message.key] = Object.freeze(node.hook.message.dispatch(message));\n        node.emit(e, message);\n    }\n    return store;\n}\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n */\nfunction touchMessages(messageStore, store) {\n    for (const key in messageStore) {\n        const message = { ...messageStore[key] };\n        store.set(message);\n    }\n}\n/**\n * Remove a message from the store.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n * @returns FormKitStore\n */\nfunction removeMessage(messageStore, store, node, key) {\n    if (has(messageStore, key)) {\n        const message = messageStore[key];\n        delete messageStore[key];\n        node.emit('message-removed', message);\n    }\n    if (store.buffer === true) {\n        store._b = store._b.filter((buffered) => {\n            buffered[0] = buffered[0].filter((m) => m.key !== key);\n            return buffered[1] || buffered[0].length;\n        });\n    }\n    return store;\n}\n/**\n * Iterates over all messages removing those that are no longer wanted.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n */\nfunction filterMessages(messageStore, store, node, callback, type) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        if ((!type || message.type === type) && !callback(message)) {\n            removeMessage(messageStore, store, node, key);\n        }\n    }\n}\n/**\n * Reduce the message store to some other generic value.\n * @param messageStore - The store itself\n * @param _store - Unused but curried \u2014 the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n * @returns\n */\nfunction reduceMessages(messageStore, _store, _node, reducer, accumulator) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        accumulator = reducer(accumulator, message);\n    }\n    return accumulator;\n}\n/**\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried \u2014 the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n */\nfunction applyMessages(_messageStore, store, node, messages, clear) {\n    if (Array.isArray(messages)) {\n        if (store.buffer) {\n            store._b.push([messages, clear]);\n            return;\n        }\n        // In this case we are applying messages to this node\u2019s store.\n        const applied = new Set(messages.map((message) => {\n            store.set(message);\n            return message.key;\n        }));\n        // Remove any messages that were not part of the initial apply:\n        if (typeof clear === 'string') {\n            store.filter((message) => message.type !== clear || applied.has(message.key));\n        }\n        else if (typeof clear === 'function') {\n            store.filter((message) => !clear(message) || applied.has(message.key));\n        }\n    }\n    else {\n        for (const address in messages) {\n            const child = node.at(address);\n            if (child) {\n                child.store.apply(messages[address], clear);\n            }\n            else {\n                missed(node, store, address, messages[address], clear);\n            }\n        }\n    }\n}\n/**\n * Creates an array of message arrays from strings.\n * @param errors - Arrays or objects of form errors or input errors\n * @returns\n * @internal\n */\nfunction createMessages(node, ...errors) {\n    const sourceKey = `${node.name}-set`;\n    const make = (error) => createMessage({\n        key: slugify(error),\n        type: 'error',\n        value: error,\n        meta: { source: sourceKey, autoClear: true },\n    });\n    return errors\n        .filter((m) => !!m)\n        .map((errorSet) => {\n        if (typeof errorSet === 'string')\n            errorSet = [errorSet];\n        if (Array.isArray(errorSet)) {\n            return errorSet.map((error) => make(error));\n        }\n        else {\n            const errors = {};\n            for (const key in errorSet) {\n                if (Array.isArray(errorSet[key])) {\n                    errors[key] = errorSet[key].map((error) => make(error));\n                }\n                else {\n                    errors[key] = [make(errorSet[key])];\n                }\n            }\n            return errors;\n        }\n    });\n}\n/**\n *\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n */\nfunction missed(node, store, address, messages, clear) {\n    var _a;\n    const misses = store._m;\n    if (!misses.has(address))\n        misses.set(address, []);\n    // The created receipt\n    if (!store._r)\n        store._r = releaseMissed(node, store);\n    (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages, clear]);\n}\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n * @param store - The store object.\n * @returns\n */\nfunction releaseMissed(node, store) {\n    return node.on('child.deep', ({ payload: child }) => {\n        store._m.forEach((misses, address) => {\n            if (node.at(address) === child) {\n                misses.forEach(([messages, clear]) => {\n                    child.store.apply(messages, clear);\n                });\n                store._m.delete(address);\n            }\n        });\n        // If all the stored misses were applied, remove the listener.\n        if (store._m.size === 0 && store._r) {\n            node.off(store._r);\n            store._r = undefined;\n        }\n    });\n}\n/**\n * Iterates over all buffered messages and applies them in sequence.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n */\nfunction releaseBuffer(_messageStore, store) {\n    store.buffer = false;\n    store._b.forEach(([messages, clear]) => store.apply(messages, clear));\n    store._b = [];\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n * @returns\n */\nfunction createLedger() {\n    const ledger = {};\n    let n;\n    return {\n        count: (...args) => createCounter(n, ledger, ...args),\n        init(node) {\n            n = node;\n            node.on('message-added.deep', add(ledger, 1));\n            node.on('message-removed.deep', add(ledger, -1));\n        },\n        merge: (child) => merge(n, ledger, child),\n        settled(counterName) {\n            return has(ledger, counterName)\n                ? ledger[counterName].promise\n                : Promise.resolve();\n        },\n        unmerge: (child) => merge(n, ledger, child, true),\n        value(counterName) {\n            return has(ledger, counterName) ? ledger[counterName].count : 0;\n        },\n    };\n}\n/**\n * Creates a new counter object in the counting ledger.\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param initialValue - The initial counter value\n * @returns\n */\nfunction createCounter(node, ledger, counterName, condition, increment = 0) {\n    condition = parseCondition(condition || counterName);\n    if (!has(ledger, counterName)) {\n        const counter = {\n            condition,\n            count: 0,\n            name: counterName,\n            node,\n            promise: Promise.resolve(),\n            resolve: () => { }, // eslint-disable-line @typescript-eslint/no-empty-function\n        };\n        ledger[counterName] = counter;\n        increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);\n        node.each((child) => {\n            child.ledger.count(counter.name, counter.condition);\n            increment += child.ledger.value(counter.name);\n        });\n    }\n    return count(ledger[counterName], increment).promise;\n}\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n * @param condition - The condition that, if true, allows a message to change a counter's value\n * @returns\n */\nfunction parseCondition(condition) {\n    if (typeof condition === 'function') {\n        return condition;\n    }\n    return (m) => m.type === condition;\n}\n/**\n * Perform a counting action on the a given counter object of the ledger.\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n * @returns\n */\nfunction count(counter, increment) {\n    const initial = counter.count;\n    const post = counter.count + increment;\n    counter.count = post;\n    if (initial === 0 && post !== 0) {\n        counter.node.emit(`unsettled:${counter.name}`, counter.count, false);\n        counter.promise = new Promise((r) => (counter.resolve = r));\n    }\n    else if (initial !== 0 && post === 0) {\n        counter.node.emit(`settled:${counter.name}`, counter.count, false);\n        counter.resolve();\n    }\n    counter.node.emit(`count:${counter.name}`, counter.count, false);\n    return counter;\n}\n/**\n * Returns a function to be used as an event listener for message events.\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n * @returns\n */\nfunction add(ledger, delta) {\n    return (e) => {\n        for (const name in ledger) {\n            const counter = ledger[name];\n            if (counter.condition(e.payload)) {\n                count(counter, delta);\n            }\n        }\n    };\n}\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n */\nfunction merge(parent, ledger, child, remove = false) {\n    for (const key in ledger) {\n        const condition = ledger[key].condition;\n        if (!remove)\n            child.ledger.count(key, condition);\n        const increment = child.ledger.value(key) * (remove ? -1 : 1);\n        if (!parent)\n            continue;\n        do {\n            parent.ledger.count(key, condition, increment);\n            parent = parent.parent;\n        } while (parent);\n    }\n}\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry = new Map();\nconst reflected = new Map();\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter();\n/**\n * Receipts of listeners.\n */\nconst receipts = [];\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true\n * then no node is registered (idempotent).\n *\n * @param node - A node to register\n * @public\n */\nfunction register(node) {\n    if (node.props.id) {\n        registry.set(node.props.id, node);\n        reflected.set(node, node.props.id);\n        emit(node, {\n            payload: node,\n            name: node.props.id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Deregister a node from the registry.\n * @param node - A node to remove\n * @public\n */\nfunction deregister(node) {\n    if (reflected.has(node)) {\n        const id = reflected.get(node); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        reflected.delete(node);\n        registry.delete(id);\n        emit(node, {\n            payload: null,\n            name: id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Get a node by a particular id.\n * @param node - Get a node by a given id\n * @public\n */\nfunction getNode$1(id) {\n    return registry.get(id);\n}\n/**\n * Reset the entire registry.\n * @public\n */\nfunction resetRegistry() {\n    registry.forEach((node) => {\n        deregister(node);\n    });\n    receipts.forEach((receipt) => emit.off(receipt));\n}\n/**\n *\n * @param id - An id to watch\n * @param callback - A callback to notify when the node is set or removed.\n * @public\n */\nfunction watchRegistry(id, callback) {\n    // register a listener\n    receipts.push(emit.on(id, callback));\n}\n\n/**\n * Applies a given config change to the node.\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n * @internal\n */\nfunction configChange(node, prop, value) {\n    // When we return false, node.walk will not continue into that child.\n    let usingFallback = true;\n    !(prop in node.config._t)\n        ? node.emit(`config:${prop}`, value, false)\n        : (usingFallback = false);\n    if (!(prop in node.props)) {\n        node.emit('prop', { prop, value });\n        node.emit(`prop:${prop}`, value);\n    }\n    return usingFallback;\n}\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - FormKit node options to be used globally.\n * @public\n */\nfunction createConfig$1(options = {}) {\n    const nodes = new Set();\n    const target = {\n        ...options,\n        ...{\n            _add: (node) => nodes.add(node),\n            _rm: (node) => node.remove(node),\n        },\n    };\n    const rootConfig = new Proxy(target, {\n        set(t, prop, value, r) {\n            if (typeof prop === 'string') {\n                nodes.forEach((node) => configChange(node, prop, value));\n            }\n            return Reflect.set(t, prop, value, r);\n        },\n    });\n    return rootConfig;\n}\n\n/**\n * Submits a FormKit form programmatically.\n * @param id - The id of the form\n * @public\n */\nfunction submitForm(id) {\n    const formElement = document.getElementById(id);\n    if (formElement instanceof HTMLFormElement) {\n        const event = new Event('submit', { cancelable: true, bubbles: true });\n        formElement.dispatchEvent(event);\n        return;\n    }\n    warn(151, id);\n}\n\n/**\n * Clear all state and error messages.\n */\nfunction clearState(node) {\n    const clear = (n) => {\n        for (const key in n.store) {\n            const message = n.store[key];\n            if (message.type === 'error' ||\n                (message.type === 'ui' && key === 'incomplete')) {\n                n.store.remove(key);\n            }\n            else if (message.type === 'state') {\n                n.store.set({ ...message, value: false });\n            }\n        }\n    };\n    clear(node);\n    node.walk(clear);\n}\n/**\n * Resets an input to it\u2019s \"initial\" value \u2014 if the input is a group or list it\n * resets all the children as well.\n * @param id - The id of an input to reset\n * @returns\n * @public\n */\nfunction reset(id, resetTo) {\n    const node = typeof id === 'string' ? getNode$1(id) : id;\n    if (node) {\n        const initial = (n) => cloneAny(n.props.initial) ||\n            (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined);\n        // pause all events in this tree.\n        node._e.pause(node);\n        // Set it back to basics\n        node.input(cloneAny(resetTo) || initial(node), false);\n        // Set children back to basics in case they were additive (had their own value for example)\n        node.walk((child) => child.input(initial(child), false));\n        // Finally we need to lay any values back on top (if it is a group/list) since group values\n        // take precedence over child values.\n        const finalInit = initial(node);\n        node.input(typeof finalInit === 'object'\n            ? cloneAny(resetTo) || init(finalInit)\n            : finalInit, false);\n        // release the events.\n        node._e.play(node);\n        clearState(node);\n        node.emit('reset', node);\n        return node;\n    }\n    warn(152, id);\n    return;\n}\n\n/**\n * Default configuration options.\n */\nconst defaultConfig = {\n    delimiter: '.',\n    delay: 0,\n    locale: 'en',\n    rootClasses: (key) => ({ [`formkit-${kebab(key)}`]: true }),\n};\n/**\n * If a node\u2019s name is set to useIndex, it replaces the node\u2019s name with the\n * index of the node relative to its parent\u2019s children.\n * @public\n */\nconst useIndex = Symbol('index');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n * @public\n */\nconst valueRemoved = Symbol('removed');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n * @public\n */\nconst valueMoved = Symbol('moved');\n/**\n * When creating a new node and having its value injected directly at a specific\n * location.\n * @public\n */\nconst valueInserted = Symbol('inserted');\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n * @param arg -\n * @returns arg is FormKitListContext\n * @public\n */\nfunction isList(arg) {\n    return arg.type === 'list' && Array.isArray(arg._value);\n}\n/**\n * Determine if a given object is a node\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isNode(node) {\n    return node && typeof node === 'object' && node.__FKNode__ === true;\n}\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (node, _context, property) => {\n    error(102, [node, property]);\n};\nconst traps = {\n    _c: trap(getContext, invalidSetter, false),\n    add: trap(addChild),\n    addProps: trap(addProps),\n    address: trap(getAddress, invalidSetter, false),\n    at: trap(getNode),\n    bubble: trap(bubble),\n    clearErrors: trap(clearErrors$1),\n    calm: trap(calm),\n    config: trap(false),\n    define: trap(define),\n    disturb: trap(disturb),\n    destroy: trap(destroy),\n    hydrate: trap(hydrate),\n    index: trap(getIndex, setIndex, false),\n    input: trap(input),\n    each: trap(eachChild),\n    emit: trap(emit$1),\n    find: trap(find),\n    on: trap(on),\n    off: trap(off),\n    parent: trap(false, setParent),\n    plugins: trap(false),\n    remove: trap(removeChild),\n    root: trap(getRoot, invalidSetter, false),\n    reset: trap(resetValue),\n    resetConfig: trap(resetConfig),\n    setErrors: trap(setErrors$1),\n    submit: trap(submit),\n    t: trap(text),\n    use: trap(use),\n    name: trap(getName, false, false),\n    walk: trap(walkTree),\n};\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps() {\n    return new Map(Object.entries(traps));\n}\n/**\n * Creates a getter/setter trap and curries the context/node pair\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n * @returns\n */\nfunction trap(getter, setter, curryGetter = true) {\n    return {\n        get: getter\n            ? (node, context) => curryGetter\n                ? (...args) => getter(node, context, ...args)\n                : getter(node, context)\n            : false,\n        set: setter !== undefined ? setter : invalidSetter.bind(null),\n    };\n}\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks() {\n    const hooks = new Map();\n    return new Proxy(hooks, {\n        get(_, property) {\n            if (!hooks.has(property)) {\n                hooks.set(property, createDispatcher());\n            }\n            return hooks.get(property);\n        },\n    });\n}\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0;\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0;\n/**\n * Reports the global number of node registrations, useful for deterministic\n * node naming.\n * @public\n */\nfunction resetCount() {\n    nameCount = 0;\n    idCount = 0;\n}\n/**\n * Create a name based dictionary of all children in an array.\n * @param children -\n * @public\n */\nfunction names(children) {\n    return children.reduce((named, child) => Object.assign(named, { [child.name]: child }), {});\n}\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options -\n * @returns string\n */\nfunction createName(options) {\n    var _a, _b;\n    if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return useIndex;\n    return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || 'input'}_${++nameCount}`;\n}\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n * @param options -\n * @param type -\n * @returns\n * @internal\n */\nfunction createValue(options) {\n    if (options.type === 'group') {\n        return init(options.value &&\n            typeof options.value === 'object' &&\n            !Array.isArray(options.value)\n            ? options.value\n            : {});\n    }\n    else if (options.type === 'list') {\n        return init(Array.isArray(options.value) ? options.value : []);\n    }\n    return options.value === null ? '' : options.value;\n}\n/**\n * Sets the internal value of the node.\n * @param node -\n * @param context -\n * @param value -\n * @returns T\n */\nfunction input(node, context, value, async = true) {\n    context._value = validateInput(node, node.hook.input.dispatch(value));\n    node.emit('input', context._value);\n    if (context.isSettled)\n        node.disturb();\n    if (async) {\n        if (context._tmo)\n            clearTimeout(context._tmo);\n        context._tmo = setTimeout(commit, node.props.delay, node, context);\n    }\n    else {\n        commit(node, context);\n    }\n    return context.settled;\n}\n/**\n * Validate that the current input is allowed.\n * @param type - The type of node (input, list, group)\n * @param value - The value that is being set\n */\nfunction validateInput(node, value) {\n    switch (node.type) {\n        // Inputs are allowed to have any type\n        case 'input':\n            break;\n        case 'group':\n            if (!value || typeof value !== 'object')\n                error(107, [node, value]);\n            break;\n        case 'list':\n            if (!Array.isArray(value))\n                error(108, [node, value]);\n            break;\n    }\n    return value;\n}\n/**\n * Commits the working value to the node graph as the value of this node.\n * @param node -\n * @param context -\n * @param calm -\n * @param hydrate -\n */\nfunction commit(node, context, calm = true, hydrate = true) {\n    context._value = context.value = node.hook.commit.dispatch(context._value);\n    if (node.type !== 'input' && hydrate)\n        node.hydrate();\n    node.emit('commit', context.value);\n    if (calm)\n        node.calm();\n}\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n * @param context -\n * @param name -\n * @param value -\n */\nfunction partial(context, { name, value, from }) {\n    if (Object.isFrozen(context._value))\n        return;\n    if (isList(context)) {\n        const insert = value === valueRemoved\n            ? []\n            : value === valueMoved && typeof from === 'number'\n                ? context._value.splice(from, 1)\n                : [value];\n        context._value.splice(name, value === valueMoved || from === valueInserted ? 0 : 1, ...insert);\n        return;\n    }\n    // In this case we know for sure we're dealing with a group, TS doesn't\n    // know that however, so we use some unpleasant casting here\n    if (value !== valueRemoved) {\n        context._value[name] = value;\n    }\n    else {\n        delete context._value[name];\n    }\n}\n/**\n * Pass values down to children by calling hydrate on them.\n * @param parent -\n * @param child -\n */\nfunction hydrate(node, context) {\n    const _value = context._value;\n    context.children.forEach((child) => {\n        if (typeof _value !== 'object')\n            return;\n        // if (has(context._value as FormKitGroupValue, child.name)) {\n        if (child.name in _value) {\n            // In this case, the parent has a value to give to the child, so we\n            // perform a down-tree synchronous input which will cascade values down\n            // and then ultimately back up.\n            const childValue = child.type !== 'input' ||\n                (_value[child.name] && typeof _value[child.name] === 'object')\n                ? init(_value[child.name])\n                : _value[child.name];\n            child.input(childValue, false);\n        }\n        else {\n            if (node.type !== 'list' || typeof child.name === 'number') {\n                // In this case, the parent\u2019s values have no knowledge of the child\n                // value \u2014 this typically occurs on the commit at the end of addChild()\n                // we need to create a value reservation for this node\u2019s name. This is\n                // especially important when dealing with lists where index matters.\n                partial(context, { name: child.name, value: child.value });\n            }\n            if (!_value.__init) {\n                // In this case, someone has explicitly set the value to an empty object\n                // with node.input({}) so we do not define the __init property:\n                if (child.type === 'group')\n                    child.input({}, false);\n                else if (child.type === 'list')\n                    child.input([], false);\n                else\n                    child.input(undefined, false);\n            }\n        }\n    });\n    return node;\n}\n/**\n * Disturbs the state of a node from settled to unsettled\u00A0\u2014 creating appropriate\n * promises and resolutions.\n * @param node -\n * @param context -\n */\nfunction disturb(node, context) {\n    var _a;\n    if (context._d <= 0) {\n        context.isSettled = false;\n        node.emit('settled', false, false);\n        context.settled = new Promise((resolve) => {\n            context._resolve = resolve;\n        });\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();\n    }\n    context._d++;\n    return node;\n}\n/**\n * Calms the given node's disturbed state by one.\n * @param node -\n * @param context -\n */\nfunction calm(node, context, value) {\n    var _a;\n    if (value !== undefined && node.type !== 'input') {\n        partial(context, value);\n        // Commit the value up, but do not hydrate back down\n        return commit(node, context, true, false);\n    }\n    if (context._d > 0)\n        context._d--;\n    if (context._d === 0) {\n        context.isSettled = true;\n        node.emit('settled', true, false);\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });\n        if (context._resolve)\n            context._resolve(context.value);\n    }\n}\n/**\n * This node is being removed and needs to be cleaned up.\n * @param node - The node to shut down\n * @param context - The context to clean up\n */\nfunction destroy(node, context) {\n    node.emit('destroying', node);\n    // flush all messages out\n    node.store.filter(() => false);\n    if (node.parent) {\n        node.parent.remove(node);\n    }\n    deregister(node);\n    context._value = context.value = undefined;\n    node.emit('destroyed', node);\n}\n/**\n * Defines the current input type concretely.\n * @param definition - The definition of the current input type.\n */\nfunction define(node, context, definition) {\n    // Assign the type\n    context.type = definition.type;\n    // Assign the definition\n    context.props.definition = clone(definition);\n    // Ensure the type is seeded with the `__init` value.\n    context.value = context._value = createValue({\n        type: node.type,\n        value: context.value,\n    });\n    // Apply any input features before resetting the props.\n    if (definition.features) {\n        definition.features.forEach((feature) => feature(node));\n    }\n    // Its possible that input-defined \"props\" have ended up in the context attrs\n    // these should be moved back out of the attrs object.\n    if (definition.props) {\n        node.addProps(definition.props);\n    }\n    node.emit('defined', definition);\n}\n/**\n * Adds props to a given node by stripping them out of the node.props.attrs and\n * then adding them to the nodes.\n *\n * @param node - The node to add props to\n * @param context - The internal context object\n * @param props - An array of prop strings (in camelCase!)\n */\nfunction addProps(node, context, props) {\n    var _a;\n    if (node.props.attrs) {\n        const attrs = { ...node.props.attrs };\n        // Temporarily disable prop emits\n        node.props._emit = false;\n        for (const attr in attrs) {\n            const camelName = camel(attr);\n            if (props.includes(camelName)) {\n                node.props[camelName] = attrs[attr];\n                delete attrs[attr];\n            }\n        }\n        const initial = cloneAny(context._value);\n        node.props.initial =\n            node.type !== 'input' ? init(initial) : initial;\n        // Re-enable prop emits\n        node.props._emit = true;\n        node.props.attrs = attrs;\n        if (node.props.definition) {\n            node.props.definition.props = [\n                ...(((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.props) || []),\n                ...props,\n            ];\n        }\n    }\n    node.emit('added-props', props);\n    return node;\n}\n/**\n * (node.add) Adds a child to the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction addChild(parent, parentContext, child, listIndex) {\n    if (parent.type === 'input')\n        error(100, parent);\n    if (child.parent && child.parent !== parent) {\n        child.parent.remove(child);\n    }\n    // Synchronously set the initial value on the parent\n    if (!parentContext.children.includes(child)) {\n        if (listIndex !== undefined && parent.type === 'list') {\n            // Inject the child:\n            parentContext.children.splice(listIndex, 0, child);\n            if (Array.isArray(parent.value) &&\n                parent.value.length < parentContext.children.length) {\n                // When adding an node or value to a list it is absolutely critical to\n                // know if, at the moment of injection, the parent\u2019s value or the node\n                // children are the source of truth. For example, if a user pushes or\n                // splices a new value onto the lists\u2019s array then we want to use that\n                // value as the value of the new node, but if a user adds a node to the\n                // list then we want the node\u2019s value. In this specific case, we\n                // assume (due to length) that a new node was injected into the list, so\n                // we want that new node\u2019s value injected into the parent list value.\n                parent.disturb().calm({\n                    name: listIndex,\n                    value: child.value,\n                    from: valueInserted,\n                });\n            }\n        }\n        else {\n            parentContext.children.push(child);\n        }\n        if (!child.isSettled)\n            parent.disturb();\n    }\n    if (child.parent !== parent) {\n        child.parent = parent;\n        // In this edge case middleware changed the parent assignment so we need to\n        // re-add the child\n        if (child.parent !== parent) {\n            parent.remove(child);\n            child.parent.add(child);\n            return parent;\n        }\n    }\n    else {\n        // When a parent is properly assigned, we inject the parent's plugins on the\n        // child.\n        child.use(parent.plugins);\n    }\n    // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n    // resolve any conflict between the parent and child values, and also ensure\n    // proper \"placeholders\" are made on the parent.\n    commit(parent, parentContext, false);\n    parent.ledger.merge(child);\n    parent.emit('child', child);\n    return parent;\n}\n/**\n * The setter for node.parent = FormKitNode\n * @param _context -\n * @param node -\n * @param _property -\n * @param parent -\n * @returns boolean\n */\nfunction setParent(child, context, _property, parent) {\n    if (isNode(parent)) {\n        if (child.parent && child.parent !== parent) {\n            child.parent.remove(child);\n        }\n        context.parent = parent;\n        child.resetConfig();\n        !parent.children.includes(child)\n            ? parent.add(child)\n            : child.use(parent.plugins);\n        return true;\n    }\n    if (parent === null) {\n        context.parent = null;\n        return true;\n    }\n    return false;\n}\n/**\n * (node.remove) Removes a child from the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction removeChild(node, context, child) {\n    const childIndex = context.children.indexOf(child);\n    if (childIndex !== -1) {\n        if (child.isSettled)\n            node.disturb();\n        context.children.splice(childIndex, 1);\n        // If an ancestor uses the preserve prop, then we are expected to not remove\n        // our values on this node either, see #53\n        let preserve = undefine(child.props.preserve);\n        let parent = child.parent;\n        while (preserve === undefined && parent) {\n            preserve = undefine(parent.props.preserve);\n            parent = parent.parent;\n        }\n        if (!preserve) {\n            node.calm({\n                name: node.type === 'list' ? childIndex : child.name,\n                value: valueRemoved,\n            });\n        }\n        else {\n            node.calm();\n        }\n        child.parent = null;\n        // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n        child.config._rmn = child;\n    }\n    node.ledger.unmerge(child);\n    return node;\n}\n/**\n * Iterate over each immediate child and perform a callback.\n * @param context -\n * @param _node -\n * @param callback -\n */\nfunction eachChild(_node, context, callback) {\n    context.children.forEach((child) => callback(child));\n}\n/**\n * Walk all nodes below this one and execute a callback.\n * @param _node -\n * @param context -\n * @param callback -\n */\nfunction walkTree(_node, context, callback, stopIfFalse = false) {\n    context.children.forEach((child) => {\n        if (callback(child) !== false || !stopIfFalse) {\n            child.walk(callback);\n        }\n    });\n}\n/**\n * Set the configuration options of the node and it's subtree.\n * @param node -\n * @param context -\n * @param _property -\n * @param config -\n */\nfunction resetConfig(node, context) {\n    const parent = node.parent || undefined;\n    context.config = createConfig(node.config._t, parent);\n    node.walk((n) => n.resetConfig());\n}\n/**\n * Adds a plugin to the node, it\u2019s children, and executes it.\n * @param context -\n * @param node -\n * @param plugin -\n * @public\n */\nfunction use(node, context, plugin, run = true, library = true) {\n    if (Array.isArray(plugin) || plugin instanceof Set) {\n        plugin.forEach((p) => use(node, context, p));\n        return node;\n    }\n    if (!context.plugins.has(plugin)) {\n        if (library && typeof plugin.library === 'function')\n            plugin.library(node);\n        // When plugins return false, they are never added as to the plugins Set\n        // meaning they only ever have access to the single node they were added on.\n        if (run && plugin(node) !== false) {\n            context.plugins.add(plugin);\n            node.children.forEach((child) => child.use(plugin));\n        }\n    }\n    return node;\n}\n/**\n * Moves a node in the parent\u2019s children to the given index.\n * @param node -\n * @param _context -\n * @param _property -\n * @param setIndex -\n */\nfunction setIndex(node, _context, _property, setIndex) {\n    if (isNode(node.parent)) {\n        const children = node.parent.children;\n        const index = setIndex >= children.length\n            ? children.length - 1\n            : setIndex < 0\n                ? 0\n                : setIndex;\n        const oldIndex = children.indexOf(node);\n        if (oldIndex === -1)\n            return false;\n        children.splice(oldIndex, 1);\n        children.splice(index, 0, node);\n        node.parent.children = children;\n        if (node.parent.type === 'list')\n            node.parent\n                .disturb()\n                .calm({ name: index, value: valueMoved, from: oldIndex });\n        return true;\n    }\n    return false;\n}\n/**\n * Retrieves the index of a node from the parent\u2019s children.\n * @param node -\n */\nfunction getIndex(node) {\n    if (node.parent) {\n        const index = [...node.parent.children].indexOf(node);\n        // If the index is currently -1 then the node isnt finished booting, so it\n        // must be the next node.\n        return index === -1 ? node.parent.children.length : index;\n    }\n    return -1;\n}\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n * @param _node -\n * @param context -\n */\nfunction getContext(_node, context) {\n    return context;\n}\n/**\n * Get the name of the current node, allowing for slight mutations.\n * @param node -\n * @param context -\n */\nfunction getName(node, context) {\n    var _a;\n    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return node.index;\n    return context.name !== useIndex ? context.name : node.index;\n}\n/**\n * Returns the address of the current node.\n * @param node -\n * @param context -\n */\nfunction getAddress(node, context) {\n    return context.parent\n        ? context.parent.address.concat([node.name])\n        : [node.name];\n}\n/**\n * Fetches a node from the tree by its address.\n * @param context -\n * @param node -\n * @param location -\n * @returns FormKitNode\n */\nfunction getNode(node, _context, locator) {\n    const address = typeof locator === 'string' ? locator.split(node.config.delimiter) : locator;\n    if (!address.length)\n        return undefined;\n    const first = address[0];\n    let pointer = node.parent;\n    if (!pointer) {\n        // This address names the root node, remove it to get child name:\n        if (String(address[0]) === String(node.name))\n            address.shift();\n        // All root nodes start at themselves ultimately:\n        pointer = node;\n    }\n    // Any addresses starting with $parent should discard it\n    if (first === '$parent')\n        address.shift();\n    while (pointer && address.length) {\n        const name = address.shift();\n        switch (name) {\n            case '$root':\n                pointer = node.root;\n                break;\n            case '$parent':\n                pointer = pointer.parent;\n                break;\n            case '$self':\n                pointer = node;\n                break;\n            default:\n                pointer =\n                    pointer.children.find((c) => String(c.name) === String(name)) ||\n                        select(pointer, name);\n        }\n    }\n    return pointer || undefined;\n}\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n * @param node -\n * @param selector -\n * @returns FormKitNode | undefined\n */\nfunction select(node, selector) {\n    const matches = String(selector).match(/^(find)\\((.*)\\)$/);\n    if (matches) {\n        const [, action, argStr] = matches;\n        const args = argStr.split(',').map((arg) => arg.trim());\n        switch (action) {\n            case 'find':\n                return node.find(args[0], args[1]);\n            default:\n                return undefined;\n        }\n    }\n    return undefined;\n}\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n * @param node - The node to start the search on/under\n * @param _context - The context object\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key to search on, or a function\n * @returns\n */\nfunction find(node, _context, searchTerm, searcher) {\n    return bfs(node, searchTerm, searcher);\n}\n/**\n * Perform a breadth-first-search on a node subtree and locate the first\n * instance of a match.\n * @param node -\n * @param name -\n * @returns FormKitNode\n * @public\n */\nfunction bfs(tree, searchValue, searchGoal = 'name') {\n    const search = typeof searchGoal === 'string'\n        ? (n) => n[searchGoal] == searchValue // non-strict comparison is intentional\n        : searchGoal;\n    const stack = [tree];\n    while (stack.length) {\n        const node = stack.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        if (search(node, searchValue))\n            return node;\n        stack.push(...node.children);\n    }\n    return undefined;\n}\n/**\n * Get the root node of the tree.\n */\nfunction getRoot(n) {\n    let node = n;\n    while (node.parent) {\n        node = node.parent;\n    }\n    return node;\n}\n/**\n * Creates a new configuration option.\n * @param parent -\n * @param configOptions -\n * @returns FormKitConfig\n */\nfunction createConfig(target = {}, parent) {\n    let node = undefined;\n    return new Proxy(target, {\n        get(...args) {\n            const prop = args[1];\n            if (prop === '_t')\n                return target;\n            const localValue = Reflect.get(...args);\n            // Check our local values first\n            if (localValue !== undefined)\n                return localValue;\n            // Then check our parent values next\n            if (parent) {\n                const parentVal = parent.config[prop];\n                if (parentVal !== undefined)\n                    return parentVal;\n            }\n            if (target.rootConfig && typeof prop === 'string') {\n                const rootValue = target.rootConfig[prop];\n                if (rootValue !== undefined)\n                    return rootValue;\n            }\n            // The default delay value should be 20\n            if (prop === 'delay' && (node === null || node === void 0 ? void 0 : node.type) === 'input')\n                return 20;\n            // Finally check the default values\n            return defaultConfig[prop];\n        },\n        set(...args) {\n            const prop = args[1];\n            const value = args[2];\n            if (prop === '_n') {\n                node = value;\n                if (target.rootConfig)\n                    target.rootConfig._add(node);\n                return true;\n            }\n            if (prop === '_rmn') {\n                if (target.rootConfig)\n                    target.rootConfig._rm(node);\n                node = undefined;\n                return true;\n            }\n            if (!eq(target[prop], value, false)) {\n                const didSet = Reflect.set(...args);\n                if (node) {\n                    node.emit(`config:${prop}`, value, false);\n                    configChange(node, prop, value);\n                    // Walk the node tree and notify of config/prop changes where relevant\n                    node.walk((n) => configChange(n, prop, value), true);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n * @param key - A message key, or generic string of text\n * @returns\n */\nfunction text(node, _context, key, type = 'ui') {\n    const fragment = typeof key === 'string' ? { key, value: key, type } : key;\n    const value = node.hook.text.dispatch(fragment);\n    node.emit('text', value, false);\n    return value.value;\n}\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n * @param node - The node to initiate the submit\n */\nfunction submit(node) {\n    const name = node.name;\n    do {\n        if (node.props.isForm === true)\n            break;\n        if (!node.parent)\n            error(106, name);\n        node = node.parent;\n    } while (node);\n    if (node.props.id) {\n        submitForm(node.props.id);\n    }\n}\n/**\n * Reset to the original value.\n * @param node - The node to reset\n * @param _context - The context\n * @param value - The value to reset to\n */\nfunction resetValue(node, _context, value) {\n    return reset(node, value);\n}\n/**\n * Sets errors on the node and optionally its children.\n * @param node - The node to set errors on\n * @param _context - Not used\n * @param localErrors - An array of errors to set on this node\n * @param childErrors - An object of name to errors to set on children.\n */\nfunction setErrors$1(node, _context, localErrors, childErrors) {\n    const sourceKey = `${node.name}-set`;\n    const errors = node.hook.setErrors.dispatch({ localErrors, childErrors });\n    createMessages(node, errors.localErrors, errors.childErrors).forEach((errors) => {\n        node.store.apply(errors, (message) => message.meta.source === sourceKey);\n    });\n    return node;\n}\n/**\n * Clears errors on the node and optionally its children.\n * @param node - The node to set errors on\n * @param _context - Not used\n * @param localErrors - An array of errors to set on this node\n * @param childErrors - An object of name to errors to set on children.\n */\nfunction clearErrors$1(node, context, clearChildErrors = true, sourceKey) {\n    setErrors$1(node, context, []);\n    if (clearChildErrors) {\n        sourceKey = sourceKey || `${node.name}-set`;\n        node.walk((child) => {\n            child.store.filter((message) => {\n                return !(message.type === 'error' &&\n                    message.meta &&\n                    message.meta.source === sourceKey);\n            });\n        });\n    }\n    return node;\n}\n/**\n * Middleware to assign default prop values as issued by core.\n * @param node - The node being registered\n * @param next - Calls the next middleware.\n * @returns\n */\nfunction defaultProps(node) {\n    if (!has(node.props, 'id'))\n        node.props.id = `input_${idCount++}`;\n    return node;\n}\n/**\n * @param options -\n * @param config -\n */\nfunction createProps(initial) {\n    const props = {\n        initial: typeof initial === 'object' ? cloneAny(initial) : initial,\n    };\n    let node;\n    let isEmitting = true;\n    return new Proxy(props, {\n        get(...args) {\n            const [_t, prop] = args;\n            if (has(props, prop))\n                return Reflect.get(...args);\n            if (node && typeof prop === 'string' && node.config[prop] !== undefined)\n                return node.config[prop];\n            return undefined;\n        },\n        set(target, property, originalValue, receiver) {\n            if (property === '_n') {\n                node = originalValue;\n                return true;\n            }\n            if (property === '_emit') {\n                isEmitting = originalValue;\n                return true;\n            }\n            const { prop, value } = node.hook.prop.dispatch({\n                prop: property,\n                value: originalValue,\n            });\n            // Typescript compiler cannot handle a symbol index, even though js can:\n            if (!eq(props[prop], value, false) ||\n                typeof value === 'object') {\n                const didSet = Reflect.set(target, prop, value, receiver);\n                if (isEmitting) {\n                    node.emit('prop', { prop, value });\n                    if (typeof prop === 'string')\n                        node.emit(`prop:${prop}`, value);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n * @param node - A formkit node\n * @param plugins - An array of plugins\n * @returns\n */\nfunction findDefinition(node, plugins) {\n    // If the definition is already there, force call to define.\n    if (node.props.definition)\n        return node.define(node.props.definition);\n    for (const plugin of plugins) {\n        if (node.props.definition)\n            return;\n        if (typeof plugin.library === 'function') {\n            plugin.library(node);\n        }\n    }\n}\n/**\n * Create a new context object for our a FormKit node, given default information\n * @param options - An options object to override the defaults.\n * @returns FormKitContext\n */\nfunction createContext(options) {\n    const value = createValue(options);\n    const config = createConfig(options.config || {}, options.parent);\n    return {\n        _d: 0,\n        _e: createEmitter(),\n        _resolve: false,\n        _tmo: false,\n        _value: value,\n        children: dedupe(options.children || []),\n        config,\n        hook: createHooks(),\n        isCreated: false,\n        isSettled: true,\n        ledger: createLedger(),\n        name: createName(options),\n        parent: options.parent || null,\n        plugins: new Set(),\n        props: createProps(value),\n        settled: Promise.resolve(value),\n        store: createStore(true),\n        traps: createTraps(),\n        type: options.type || 'input',\n        value,\n    };\n}\n/**\n * Initialize a node object's internal properties.\n * @param node - The node to initialize\n * @returns FormKitNode\n */\nfunction nodeInit(node, options) {\n    var _a;\n    // Set the internal node on the props, config, ledger and store\n    node.ledger.init((node.store._n = node.props._n = node.config._n = node));\n    // Apply given in options to the node.\n    node.props._emit = false;\n    if (options.props)\n        Object.assign(node.props, options.props);\n    node.props._emit = true;\n    // Attempt to find a definition from the pre-existing plugins.\n    findDefinition(node, new Set([\n        ...(options.plugins || []),\n        ...(node.parent ? node.parent.plugins : []),\n    ]));\n    // Then we apply each plugin's root code, we do this with an explicit loop\n    // for that ity-bitty performance bump.\n    if (options.plugins) {\n        for (const plugin of options.plugins) {\n            use(node, node._c, plugin, true, false);\n        }\n    }\n    // Initialize the default props\n    defaultProps(node);\n    // Apply the parent to each child.\n    node.each((child) => node.add(child));\n    // If the node has a parent, ensure it's properly nested bi-directionally.\n    if (node.parent)\n        node.parent.add(node, options.index);\n    // Inputs are leafs, and cannot have children\n    if (node.type === 'input' && node.children.length)\n        error(100, node);\n    // Apply the input hook to the initial value.\n    input(node, node._c, node._value, false);\n    // Release the store buffer\n    node.store.release();\n    // Register the node globally if someone explicitly gave it an id\n    if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id)\n        register(node);\n    // Our node is finally ready, emit it to the world\n    node.emit('created', node);\n    node.isCreated = true;\n    return node;\n}\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of\n * a FormKit graph.\n *\n * @param options - An object of options to define the node.\n * @returns FormKitNode\n * @public\n */\nfunction createNode(options) {\n    const ops = options || {};\n    const context = createContext(ops);\n    // Note: The typing for the proxy object cannot be fully modeled, thus we are\n    // force-typing to a FormKitNode. See:\n    // https://github.com/microsoft/TypeScript/issues/28067\n    const node = new Proxy(context, {\n        get(...args) {\n            const [, property] = args;\n            if (property === '__FKNode__')\n                return true;\n            const trap = context.traps.get(property);\n            if (trap && trap.get)\n                return trap.get(node, context);\n            return Reflect.get(...args);\n        },\n        set(...args) {\n            const [, property, value] = args;\n            const trap = context.traps.get(property);\n            if (trap && trap.set)\n                return trap.set(node, context, property, value);\n            return Reflect.set(...args);\n        },\n    });\n    return nodeInit(node, ops);\n}\n\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isDOM(node) {\n    return typeof node !== 'string' && has(node, '$el');\n}\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isComponent(node) {\n    return typeof node !== 'string' && has(node, '$cmp');\n}\n/**\n * Root declaration.\n * @param node - An object to check\n * @returns\n * @public\n */\nfunction isConditional(node) {\n    if (!node || typeof node === 'string')\n        return false;\n    return has(node, 'if') && has(node, 'then');\n}\n/**\n * Determines if the node is syntactic sugar or not.\n * @param node - Node\n * @returns\n * @public\n */\nfunction isSugar(node) {\n    return typeof node !== 'string' && '$formkit' in node;\n}\n/**\n * Converts syntactic sugar nodes to standard nodes.\n * @param node - A node to covert\n * @returns\n * @public\n */\nfunction sugar(node) {\n    if (typeof node === 'string') {\n        return {\n            $el: 'text',\n            children: node,\n        };\n    }\n    if (isSugar(node)) {\n        const { $formkit: type, for: iterator, if: condition, children, bind, ...props } = node;\n        return Object.assign({\n            $cmp: 'FormKit',\n            props: { ...props, type },\n        }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, bind ? { bind } : {});\n    }\n    return node;\n}\n\n/**\n * Compiles a logical string like \"a != z || b == c\" into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n * @param expr - A string to compile\n * @returns\n * @public\n */\nfunction compile(expr) {\n    /**\n     * These tokens are replacements used in evaluating a given condition.\n     */\n    // const tokens: FormKitTokens = {}\n    /**\n     * The value of the provide() callback. Used for late binding.\n     */\n    let provideTokens;\n    /**\n     * These are token requirements like \"$name.value\" that are need to fulfill\n     * a given condition call.\n     */\n    const requirements = new Set();\n    /**\n     * Expands the current value if it is a function.\n     * @param operand - A left or right hand operand\n     * @returns\n     */\n    const x = function expand(operand, tokens) {\n        return typeof operand === 'function' ? operand(tokens) : operand;\n    };\n    /**\n     * Comprehensive list of operators. This list MUST be\n     * ordered by the length of the operator characters in descending order.\n     */\n    const operatorRegistry = [\n        {\n            '&&': (l, r, t) => x(l, t) && x(r, t),\n            '||': (l, r, t) => x(l, t) || x(r, t),\n        },\n        {\n            '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n            '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n            '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n            '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n            '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n            '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n            '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n            '<': (l, r, t) => !!(x(l, t) < x(r, t)),\n        },\n        {\n            '+': (l, r, t) => x(l, t) + x(r, t),\n            '-': (l, r, t) => x(l, t) - x(r, t),\n        },\n        {\n            '*': (l, r, t) => x(l, t) * x(r, t),\n            '/': (l, r, t) => x(l, t) / x(r, t),\n            '%': (l, r, t) => x(l, t) % x(r, t),\n        },\n    ];\n    /**\n     * A full list of all operator symbols.\n     */\n    const operatorSymbols = operatorRegistry.reduce((s, g) => {\n        return s.concat(Object.keys(g));\n    }, []);\n    /**\n     * An array of the first character of each operator.\n     */\n    const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));\n    /**\n     * Determines if the current character is the start of an operator symbol, if it\n     * is, it returns that symbol.\n     * @param symbols - An array of symbols that are considered operators\n     * @param char - The current character being operated on\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @returns\n     */\n    function getOp(symbols, char, p, expression) {\n        const candidates = symbols.filter((s) => s.startsWith(char));\n        if (!candidates.length)\n            return false;\n        return candidates.find((symbol) => {\n            if (expression.length >= p + symbol.length) {\n                const nextChars = expression.substring(p, p + symbol.length);\n                if (nextChars === symbol)\n                    return symbol;\n            }\n            return false;\n        });\n    }\n    /**\n     * Determines the step number of the right or left hand operator.\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @param direction - 1 = right, 0 = left\n     */\n    function getStep(p, expression, direction = 1) {\n        let next = direction\n            ? expression.substring(p + 1).trim()\n            : expression.substring(0, p).trim();\n        if (!next.length)\n            return -1;\n        if (!direction) {\n            // left hand direction could include a function name we need to remove\n            const reversed = next.split('').reverse();\n            const start = reversed.findIndex((char) => operatorChars.has(char));\n            next = reversed.slice(start).join('');\n        }\n        const char = next[0];\n        return operatorRegistry.findIndex((operators) => {\n            const symbols = Object.keys(operators);\n            return !!getOp(symbols, char, 0, next);\n        });\n    }\n    /**\n     * Extracts a tail call. For example:\n     * ```\n     * $foo().bar(baz) + 7\n     * ```\n     * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n     *\n     * @param p - The position of a closing parenthetical.\n     * @param expression - The full expression being parsed.\n     */\n    function getTail(pos, expression) {\n        let tail = '';\n        const length = expression.length;\n        let depth = 0;\n        for (let p = pos; p < length; p++) {\n            const char = expression.charAt(p);\n            if (char === '(') {\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n            }\n            else if (depth === 0 && char === ' ') {\n                continue;\n            }\n            if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n                return [tail, p - 1];\n            }\n            else {\n                tail += char;\n            }\n        }\n        return [tail, expression.length - 1];\n    }\n    /**\n     * Parse a string expression into a function that returns a boolean. This is\n     * the magic behind schema logic like $if.\n     * @param expression - A string expression to parse\n     * @returns\n     */\n    function parseLogicals(expression, step = 0) {\n        const operators = operatorRegistry[step];\n        const length = expression.length;\n        const symbols = Object.keys(operators);\n        let depth = 0;\n        let quote = false;\n        let op = null;\n        let operand = '';\n        let left = null;\n        let operation;\n        let lastChar = '';\n        let char = '';\n        let parenthetical = '';\n        let parenQuote = '';\n        let startP = 0;\n        const addTo = (depth, char) => {\n            depth ? (parenthetical += char) : (operand += char);\n        };\n        for (let p = 0; p < length; p++) {\n            lastChar = char;\n            char = expression.charAt(p);\n            if ((char === \"'\" || char === '\"') &&\n                lastChar !== '\\\\' &&\n                ((depth === 0 && !quote) || (depth && !parenQuote))) {\n                if (depth) {\n                    parenQuote = char;\n                }\n                else {\n                    quote = char;\n                }\n                addTo(depth, char);\n                continue;\n            }\n            else if ((quote && (char !== quote || lastChar === '\\\\')) ||\n                (parenQuote && (char !== parenQuote || lastChar === '\\\\'))) {\n                addTo(depth, char);\n                continue;\n            }\n            else if (quote === char) {\n                quote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (parenQuote === char) {\n                parenQuote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (char === ' ') {\n                continue;\n            }\n            else if (char === '(') {\n                if (depth === 0) {\n                    startP = p;\n                }\n                else {\n                    parenthetical += char;\n                }\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n                if (depth === 0) {\n                    // Parenthetical statements cannot be grouped up in the implicit order\n                    // of left/right statements based on which step they are on because\n                    // they are parsed on every step and then must be applied to the\n                    // operator. Example:\n                    //\n                    // 5 + (3) * 2\n                    //\n                    // This should yield 11 not 16. This order is normally implicit in the\n                    // sequence of operators being parsed, but with parenthesis the parse\n                    // happens each time. Instead we need to know if the resulting value\n                    // should be applied to the left or the right hand operator. The\n                    // general algorithm is:\n                    //\n                    // 1. Does this paren have an operator on the left or right side\n                    // 2. If not, it's unnecessarily wrapped (3 + 2)\n                    // 3. If it does, then which order of operation is highest?\n                    // 4. Wait for the highest order of operation to bind to an operator.\n                    // If the parenthetical has a preceding token like $fn(1 + 2) then we\n                    // need to subtract the existing operand length from the start\n                    // to determine if this is a left or right operation\n                    const fn = typeof operand === 'string' && operand.startsWith('$')\n                        ? operand\n                        : undefined;\n                    const hasTail = fn && expression.charAt(p + 1) === '.';\n                    // It's possible the function has a chained tail call:\n                    let tail = '';\n                    if (hasTail) {\n                        [tail, p] = getTail(p + 2, expression);\n                    }\n                    const lStep = op ? step : getStep(startP, expression, 0);\n                    const rStep = getStep(p, expression);\n                    if (lStep === -1 && rStep === -1) {\n                        // This parenthetical was unnecessarily wrapped at the root, or\n                        // these are args of a function call.\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n                        // has a left hand operator with a higher order of operation\n                        left = op.bind(null, evaluate(parenthetical, -1, fn, tail));\n                        op = null;\n                        operand = '';\n                    }\n                    else if (rStep > lStep && step === rStep) {\n                        // should be applied to the right hand operator when it gets one\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else {\n                        operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`;\n                    }\n                    parenthetical = '';\n                }\n                else {\n                    parenthetical += char;\n                }\n            }\n            else if (depth === 0 &&\n                (operation = getOp(symbols, char, p, expression))) {\n                if (p === 0) {\n                    error(103, [operation, expression]);\n                }\n                // We identified the operator by looking ahead in the string, so we need\n                // our position to move past the operator\n                p += operation.length - 1;\n                if (p === expression.length - 1) {\n                    error(104, [operation, expression]);\n                }\n                if (!op) {\n                    // Bind the left hand operand\n                    if (left) {\n                        // In this case we've already parsed the left hand operator\n                        op = operators[operation].bind(null, evaluate(left, step));\n                        left = null;\n                    }\n                    else {\n                        op = operators[operation].bind(null, evaluate(operand, step));\n                        operand = '';\n                    }\n                }\n                else if (operand) {\n                    // Bind the right hand operand, and return the resulting expression as a new left hand operator\n                    left = op.bind(null, evaluate(operand, step));\n                    op = operators[operation].bind(null, left);\n                    operand = '';\n                }\n                continue;\n            }\n            else {\n                addTo(depth, char);\n            }\n        }\n        if (operand && op) {\n            // If we were left with an operand after the loop, and an op, it should\n            // be the right hand assignment.\n            op = op.bind(null, evaluate(operand, step));\n        }\n        // If we don't have an op, but we do have a left hand assignment, then that\n        // is actually our operator, so just re-assign it to op\n        op = !op && left ? left : op;\n        if (!op && operand) {\n            // If we don't have any op but we do have an operand so there is no boolean\n            // logic to perform, but that operand still means something so we need to\n            // evaluate it and return it as a function\n            op = (v, t) => {\n                return typeof v === 'function' ? v(t) : v;\n            };\n            op = op.bind(null, evaluate(operand, step));\n        }\n        if (!op && !operand) {\n            error(105, expression);\n        }\n        return op;\n    }\n    /**\n     * Given a string like '$name==bobby' evaluate it to true or false\n     * @param operand - A left or right boolean operand \u2014 usually conditions\n     * @param step - The current order of operation\n     * @param fnToken - The token (string) representation of a function being called\n     * @returns\n     */\n    function evaluate(operand, step, fnToken, tail //eslint-disable-line\n    ) {\n        if (fnToken) {\n            const fn = evaluate(fnToken, operatorRegistry.length);\n            let userFuncReturn;\n            // \"Tail calls\" are dot accessors after a function $foo().value. We need\n            // to compile tail calls, and then provide the function result to the\n            // exposed tokens.\n            let tailCall = tail\n                ? compile(`$${tail}`)\n                : false;\n            if (typeof fn === 'function') {\n                const args = parseArgs(String(operand)).map((arg) => evaluate(arg, -1));\n                return (tokens) => {\n                    const userFunc = fn(tokens);\n                    if (typeof userFunc !== 'function') {\n                        warn(150, fnToken);\n                        return userFunc;\n                    }\n                    userFuncReturn = userFunc(...args.map((arg) => typeof arg === 'function' ? arg(tokens) : arg));\n                    if (tailCall) {\n                        tailCall = tailCall.provide((subTokens) => {\n                            const rootTokens = provideTokens(subTokens);\n                            const t = subTokens.reduce((tokenSet, token) => {\n                                const isTail = token === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token}(`));\n                                if (isTail) {\n                                    const value = getAt(userFuncReturn, token);\n                                    tokenSet[token] = () => value;\n                                }\n                                else {\n                                    tokenSet[token] = rootTokens[token];\n                                }\n                                return tokenSet;\n                            }, {});\n                            return t;\n                        });\n                    }\n                    return tailCall ? tailCall() : userFuncReturn;\n                };\n            }\n        }\n        else if (typeof operand === 'string') {\n            // the word true or false will never contain further operations\n            if (operand === 'true')\n                return true;\n            if (operand === 'false')\n                return false;\n            if (operand === 'undefined')\n                return undefined;\n            // Truly quotes strings cannot contain an operation, return the string\n            if (isQuotedString(operand))\n                return rmEscapes(operand.substring(1, operand.length - 1));\n            // Actual numbers cannot be contain an operation\n            if (!isNaN(+operand))\n                return Number(operand);\n            if (step < operatorRegistry.length - 1) {\n                return parseLogicals(operand, step + 1);\n            }\n            else {\n                if (operand.startsWith('$')) {\n                    const cleaned = operand.substring(1);\n                    requirements.add(cleaned);\n                    return function getToken(tokens) {\n                        return cleaned in tokens ? tokens[cleaned]() : undefined;\n                    };\n                }\n                // In this case we are dealing with an unquoted string, just treat it\n                // as a plain string.\n                return operand;\n            }\n        }\n        return operand;\n    }\n    /**\n     * Compile the string.\n     */\n    const compiled = parseLogicals(expr.startsWith('$:') ? expr.substring(2) : expr);\n    /**\n     * Convert compiled requirements to an array.\n     */\n    const reqs = Array.from(requirements);\n    /**\n     * Provides token values via callback to compiled output.\n     * @param callback - A callback that needs to provide all token requirements\n     * @returns\n     */\n    function provide(callback) {\n        provideTokens = callback;\n        return Object.assign(compiled.bind(null, callback(reqs)), {\n            provide,\n        });\n    }\n    return Object.assign(compiled, {\n        provide,\n    });\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes\n * @param propertyKey - section key\n * @param node - FormKit node\n * @param sectionClassList - Things to turn into classes\n * @returns\n * @public\n */\nfunction createClasses(propertyKey, node, sectionClassList) {\n    if (!sectionClassList)\n        return {};\n    if (typeof sectionClassList === 'string') {\n        const classKeys = sectionClassList.split(' ');\n        return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});\n    }\n    else if (typeof sectionClassList === 'function') {\n        return createClasses(propertyKey, node, sectionClassList(node, propertyKey));\n    }\n    return sectionClassList;\n}\n/**\n * Combines multiple class lists into a single list\n * @param node - the FormKit node being operated on\n * @param property - The property key to which the class list will be applied\n * @param args - CSS class list(s)\n * @returns\n * @public\n */\nfunction generateClassList(node, property, ...args) {\n    const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n        if (!currentClassList)\n            return finalClassList;\n        const { $reset, ...classList } = currentClassList;\n        if ($reset) {\n            return classList;\n        }\n        return Object.assign(finalClassList, classList);\n    }, {});\n    return (Object.keys(node.hook.classes.dispatch({ property, classes: combinedClassList })\n        .classes)\n        .filter((key) => combinedClassList[key])\n        .join(' ') || null);\n}\n\n/**\n * Sets errors on a form, group, or input.\n * @param formId - The id of a form\n * @param localErrors - The errors to set on the form or the form\u2019s inputs\n * @param childErrors - (optional) The errors to set on the form or the form\u2019s inputs\n * @public\n */\nfunction setErrors(id, localErrors, childErrors) {\n    const node = getNode$1(id);\n    if (node) {\n        node.setErrors(localErrors, childErrors);\n    }\n    else {\n        warn(651, id);\n    }\n}\n/**\n * Clears child errors.\n * @param id - The id of the node you want to clear errors for\n * @param clearChildren - Determines if the the children of this node should have their errors cleared.\n * @public\n */\nfunction clearErrors(id, clearChildren = true) {\n    const node = getNode$1(id);\n    if (node) {\n        node.clearErrors(clearChildren);\n    }\n    else {\n        warn(652, id);\n    }\n}\n\n/**\n * index.ts\n *\n * In this file we explicitly declare what should end up in the public API.\n */\n/**\n * The current version of FormKit at the time the package is published. Is replaced\n * as part of the publishing script.\n * @public\n */\nconst FORMKIT_VERSION = '1.0.0-beta.9';\n\nexport { FORMKIT_VERSION, bfs, clearErrors, compile, createClasses, createConfig$1 as createConfig, createMessage, createNode, createValue, deregister, error, errorHandler, generateClassList, getNode$1 as getNode, isComponent, isConditional, isDOM, isList, isNode, isSugar, names, register, reset, resetCount, resetRegistry, setErrors, submitForm, sugar, use, useIndex, valueInserted, valueMoved, valueRemoved, warn, warningHandler, watchRegistry };\n", "import { extend, camel, has, kebab, isPojo, eq, undefine, clone, isObject } from '@formkit/utils';\nimport { createMessage, warn, isDOM, isComponent, isConditional } from '@formkit/core';\n\n/**\n *\n * @param libraries - One or many formkit urls.\n * @returns\n * @public\n */\nfunction createLibraryPlugin(...libraries) {\n    /**\n     * Merge all provided library items.\n     */\n    const library = libraries.reduce((merged, lib) => extend(merged, lib), {});\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    const plugin = () => { };\n    /**\n     * Enables the hook that exposes all library inputs.\n     * @param node - The primary plugin\n     */\n    plugin.library = function (node) {\n        const type = camel(node.props.type);\n        if (has(library, type)) {\n            node.define(library[type]);\n        }\n    };\n    return plugin;\n}\n\n/**\n * @public\n */\nconst outer = createSection('outer', () => ({\n    $el: 'div',\n    attrs: {\n        key: '$id',\n        'data-type': '$type',\n        'data-multiple': '$attrs.multiple',\n        'data-disabled': '$disabled || undefined',\n        'data-complete': '$state.complete || undefined',\n        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',\n        'data-errors': '$state.errors || undefined',\n        'data-submitted': '$state.submitted || undefined',\n        'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',\n        'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',\n        'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',\n        'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',\n    },\n}), true);\n\n/**\n * @public\n */\nconst inner = createSection('inner', 'div');\n\n/**\n * @public\n */\nconst wrapper = createSection('wrapper', 'div');\n\n/**\n * @public\n */\nconst label = createSection('label', () => ({\n    $el: 'label',\n    if: '$label',\n    attrs: {\n        for: '$id',\n    },\n}));\n\n/**\n * @public\n */\nconst messages = createSection('messages', () => ({\n    $el: 'ul',\n    if: '$fns.length($messages)',\n}));\n\n/**\n * @public\n */\nconst message = createSection('message', () => ({\n    $el: 'li',\n    for: ['message', '$messages'],\n    attrs: {\n        key: '$message.key',\n        id: `$id + '-' + $message.key`,\n        'data-message-type': '$message.type',\n    },\n}));\n\n/**\n * @public\n */\nconst prefix = createSection('prefix', null);\n\n/**\n * @public\n */\nconst suffix = createSection('suffix', null);\n\n/**\n * @public\n */\nconst help = createSection('help', () => ({\n    $el: 'div',\n    if: '$help',\n    attrs: {\n        id: '$: \"help-\" + $id',\n    },\n}));\n\n/**\n * @public\n */\nconst fieldset = createSection('fieldset', () => ({\n    $el: 'fieldset',\n    attrs: {\n        id: '$id',\n        'aria-describedby': {\n            if: '$help',\n            then: '$: \"help-\" + $id',\n            else: undefined,\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst decorator = createSection('decorator', () => ({\n    $el: 'span',\n    attrs: {\n        'aria-hidden': 'true',\n    },\n}));\n\n/**\n * @public\n */\nconst box = createSection('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        name: '$node.props.altName || $node.name',\n        disabled: '$option.attrs.disabled || $disabled',\n        onInput: '$handlers.toggleChecked',\n        checked: '$fns.eq($_value, $onValue)',\n        onBlur: '$handlers.blur',\n        value: '$: true',\n        id: '$id',\n        'aria-describedby': {\n            if: '$options.length',\n            then: {\n                if: '$option.help',\n                then: '$: \"help-\" + $option.attrs.id',\n                else: undefined,\n            },\n            else: {\n                if: '$help',\n                then: '$: \"help-\" + $id',\n                else: undefined,\n            },\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst legend = createSection('legend', () => ({\n    $el: 'legend',\n    if: '$label',\n}));\n\n/**\n * @public\n */\nconst boxOption = createSection('option', () => ({\n    $el: 'li',\n    for: ['option', '$options'],\n    attrs: {\n        'data-disabled': '$option.attrs.disabled || $disabled',\n    },\n}));\n\n/**\n * @public\n */\nconst boxOptions = createSection('options', 'ul');\n\n/**\n * @public\n */\nconst boxWrapper = createSection('wrapper', () => ({\n    $el: 'label',\n    attrs: {\n        'data-disabled': {\n            if: '$options.length',\n            then: undefined,\n            else: '$disabled',\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst boxHelp = createSection('optionHelp', () => ({\n    $el: 'div',\n    if: '$option.help',\n    attrs: {\n        id: '$: \"help-\" + $option.attrs.id',\n    },\n}));\n\n/**\n * @public\n */\nconst boxLabel = createSection('label', 'span');\n\n/**\n * @public\n */\nconst buttonInput = createSection('input', () => ({\n    $el: 'button',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        name: '$node.name',\n        id: '$id',\n    },\n}));\n\n/**\n * @public\n */\nconst buttonLabel = createSection('default', null);\n\n/**\n * @public\n */\nconst fileInput = createSection('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: 'file',\n        disabled: '$disabled',\n        name: '$node.name',\n        onChange: '$handlers.files',\n        onBlur: '$handlers.blur',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * @public\n */\nconst fileItem = createSection('fileItem', () => ({\n    $el: 'li',\n    for: ['file', '$value'],\n}));\n\n/**\n * @public\n */\nconst fileList = createSection('fileList', () => ({\n    $el: 'ul',\n    if: '$value.length',\n    attrs: {\n        'data-has-multiple': {\n            if: '$value.length > 1',\n            then: 'true',\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst fileName = createSection('fileName', () => ({\n    $el: 'span',\n    attrs: {\n        class: '$classes.fileName',\n    },\n}));\n\n/**\n * @public\n */\nconst fileRemove = createSection('fileRemove', () => ({\n    $el: 'button',\n    attrs: {\n        onClick: '$handlers.resetFiles',\n    },\n}));\n\n/**\n * @public\n */\nconst noFiles = createSection('noFiles', () => ({\n    $el: 'span',\n    if: '$value.length == 0',\n}));\n\n/**\n * @public\n */\nconst formInput = createSection('form', () => ({\n    $el: 'form',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        name: '$node.name',\n        onSubmit: '$handlers.submit',\n        'data-loading': '$state.loading || undefined',\n    },\n}), true);\n\n/**\n * @public\n */\nconst actions = createSection('actions', () => ({\n    $el: 'div',\n    if: '$actions',\n}));\n\n/**\n * @public\n */\nconst submitInput = createSection('submit', () => ({\n    $cmp: 'FormKit',\n    bind: '$submitAttrs',\n    props: {\n        ignore: true,\n        type: 'submit',\n        disabled: '$disabled',\n        label: '$submitLabel',\n    },\n}));\n\n/**\n * @public\n */\nconst textInput = createSection('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * @public\n */\nconst fragment = createSection('wrapper', null, true);\n\n/**\n * @public\n */\nconst selectInput$1 = createSection('input', () => ({\n    $el: 'select',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        'data-placeholder': {\n            if: '$placeholder',\n            then: {\n                if: '$value',\n                then: undefined,\n                else: 'true',\n            },\n        },\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onInput: '$handlers.selectInput',\n        onBlur: '$handlers.blur',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * @public\n */\nconst option = createSection('option', () => ({\n    $el: 'option',\n    for: ['option', '$options'],\n    bind: '$option.attrs',\n    attrs: {\n        class: '$classes.option',\n        value: '$option.value',\n        selected: '$fns.isSelected($option.value)',\n    },\n}));\n\n/**\n * @public\n */\nconst optionSlot = () => ({\n    $el: null,\n    if: '$options.length',\n    for: ['option', '$options'],\n    children: '$slots.option',\n});\n\n/**\n * @public\n */\nconst textareaInput = createSection('input', () => ({\n    $el: 'textarea',\n    bind: '$attrs',\n    attrs: {\n        disabled: '$disabled',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n    children: '$initialValue',\n}));\n\n/**\n * @public\n */\nconst icon = (sectionKey, el) => {\n    return createSection(`${sectionKey}Icon`, () => {\n        const rawIconProp = `_raw${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}Icon`;\n        return {\n            if: `$${sectionKey}Icon && $${rawIconProp}`,\n            $el: `${el ? el : 'span'}`,\n            attrs: {\n                class: `$classes.${sectionKey}Icon + \" formkit-icon\"`,\n                innerHTML: `$${rawIconProp}`,\n                onClick: `$handlers.iconClick(${sectionKey})`,\n                for: {\n                    if: `${el === 'label'}`,\n                    then: '$id'\n                }\n            }\n        };\n    })();\n};\n\n/**\n * Normalize the boxes.\n * @param node - The node\n * @returns\n * @public\n */\nfunction normalizeBoxes(node) {\n    return function (prop, next) {\n        if (prop.prop === 'options' && Array.isArray(prop.value)) {\n            prop.value = prop.value.map((option) => {\n                var _a;\n                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {\n                    return extend(option, {\n                        attrs: { id: `${node.name}-option-${kebab(String(option.value))}` },\n                    });\n                }\n                return option;\n            });\n            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\n                if (node.isCreated) {\n                    node.input([], false);\n                }\n                else {\n                    node.on('created', () => {\n                        if (!Array.isArray(node.value)) {\n                            node.input([], false);\n                        }\n                    });\n                }\n            }\n        }\n        return next(prop);\n    };\n}\n\n/**\n * Accepts an array of objects, array of strings, or object of key-value pairs.\n * and returns an array of objects with value and label properties.\n * @param options -\n */\nfunction normalizeOptions(options) {\n    let i = 1;\n    if (Array.isArray(options)) {\n        return options.map((option) => {\n            if (typeof option === 'string' || typeof option === 'number') {\n                return {\n                    label: option,\n                    value: option,\n                };\n            }\n            if (typeof option == 'object') {\n                if ('value' in option && typeof option.value !== 'string') {\n                    Object.assign(option, {\n                        value: `__mask_${i++}`,\n                        __original: option.value,\n                    });\n                }\n            }\n            return option;\n        });\n    }\n    return Object.keys(options).map((value) => {\n        return {\n            label: options[value],\n            value,\n        };\n    });\n}\n/**\n * Given an option list, find the \"true\" value in the options.\n * @param options - The options to check for a given value\n * @param value - The value to return\n * @returns\n */\nfunction optionValue(options, value) {\n    if (Array.isArray(options)) {\n        for (const option of options) {\n            if (value == option.value) {\n                return '__original' in option ? option.__original : option.value;\n            }\n        }\n    }\n    return value;\n}\n/**\n * Determines if the value should be selected.\n * @param valueA - Any type of value\n * @param valueB - Any type of value\n */\nfunction shouldSelect(valueA, valueB) {\n    if (valueA == valueB)\n        return true;\n    if (isPojo(valueA) && isPojo(valueB))\n        return eq(valueA, valueB);\n    return false;\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction options(node) {\n    node.hook.prop((prop, next) => {\n        if (prop.prop === 'options') {\n            const options = normalizeOptions(prop.value);\n            prop.value = options;\n        }\n        return next(prop);\n    });\n}\n\n/**\n * Event handler when an input is toggled.\n * @param node - The node being toggled\n * @param e - The input even related to the toggling\n * @public\n */\nfunction toggleChecked$1(node, e) {\n    const el = e.target;\n    if (el instanceof HTMLInputElement) {\n        const value = Array.isArray(node.props.options)\n            ? optionValue(node.props.options, el.value)\n            : el.value;\n        if (Array.isArray(node.props.options) && node.props.options.length) {\n            if (!Array.isArray(node._value)) {\n                // There is no array value set\n                node.input([value]);\n            }\n            else if (!node._value.some((existingValue) => shouldSelect(value, existingValue))) {\n                // The value is not in the current set\n                node.input([...node._value, value]);\n            }\n            else {\n                // Filter out equivalent values\n                node.input(node._value.filter((existingValue) => !shouldSelect(value, existingValue)));\n            }\n        }\n        else {\n            if (el.checked) {\n                node.input(node.props.onValue);\n            }\n            else {\n                node.input(node.props.offValue);\n            }\n        }\n    }\n}\n/**\n * Checks if a given option is present in the node value.\n * @param node - The node being checked\n * @param value - The value of any option\n * @returns\n */\nfunction isChecked$1(node, value) {\n    var _a, _b;\n    // We need to force vue\u2019s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    if (Array.isArray(node._value)) {\n        return node._value.some((existingValue) => shouldSelect(optionValue(node.props.options, value), existingValue));\n    }\n    return false;\n}\n/**\n * Adds checkbox selection support\n * @param node - Node the feature is added to\n * @public\n */\nfunction checkboxes(node) {\n    node.on('created', () => {\n        var _a, _b;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked$1.bind(null, node);\n        }\n        // Configure our default onValue and offValue\n        if (!has(node.props, 'onValue'))\n            node.props.onValue = true;\n        if (!has(node.props, 'offValue'))\n            node.props.offValue = false;\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Allows disabling children of this.\n * @param node - The FormKitNode of the form/group/list\n * @public\n */\nfunction disables(node) {\n    node.on('created', () => {\n        node.props.disabled = undefine(node.props.disabled);\n    });\n    node.hook.prop(({ prop, value }, next) => {\n        value = prop === 'disabled' ? undefine(value) : value;\n        return next({ prop, value });\n    });\n    node.on('prop:disabled', ({ payload: value }) => {\n        node.config.disabled = undefine(value);\n    });\n    node.on('created', () => {\n        node.config.disabled = undefine(node.props.disabled);\n    });\n}\n\n/**\n * Creates a new feature that generates a localization message of type ui\n * for use on a given component.\n *\n * @param key - The key of the message\n * @param value - The value of the message\n * @returns\n * @public\n */\nfunction localize(key, value) {\n    return (node) => {\n        node.store.set(createMessage({\n            key,\n            type: 'ui',\n            value: value || key,\n            meta: {\n                localize: true,\n                i18nArgs: [node],\n            },\n        }));\n    };\n}\n\nconst isBrowser = typeof window !== 'undefined';\n/**\n * Remove the data-file-hover attribute from the target.\n * @param e - Event\n */\nfunction removeHover(e) {\n    if (e.target instanceof HTMLElement &&\n        e.target.hasAttribute('data-file-hover')) {\n        e.target.removeAttribute('data-file-hover');\n    }\n}\n/**\n * Prevent stray drag/drop events from navigating the window.\n * @param e - Event\n * @public\n */\nfunction preventStrayDrop(type, e) {\n    if (!(e.target instanceof HTMLInputElement)) {\n        e.preventDefault();\n    }\n    else if (type === 'dragover') {\n        e.target.setAttribute('data-file-hover', 'true');\n    }\n    if (type === 'drop') {\n        removeHover(e);\n    }\n}\n/**\n * Feature to add file handling support to an input.\n * @param node - The node being checked\n * @public\n */\nfunction files(node) {\n    // Localize our content:\n    localize('noFiles', 'Select file')(node);\n    localize('removeAll', 'Remove all')(node);\n    localize('remove')(node);\n    if (isBrowser) {\n        if (!window._FormKit_File_Drop) {\n            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));\n            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));\n            window.addEventListener('dragleave', removeHover);\n            window._FormKit_File_Drop = true;\n        }\n    }\n    node.on('created', () => {\n        if (!Array.isArray(node.value)) {\n            node.input([], false);\n        }\n        if (!node.context)\n            return;\n        node.context.handlers.resetFiles = (e) => {\n            e.preventDefault();\n            node.input([]);\n            if (node.props.id && isBrowser) {\n                const el = document.getElementById(node.props.id);\n                if (el)\n                    el.value = '';\n            }\n        };\n        node.context.handlers.files = (e) => {\n            var _a, _b;\n            const files = [];\n            if (e.target instanceof HTMLInputElement && e.target.files) {\n                for (let i = 0; i < e.target.files.length; i++) {\n                    let file;\n                    if ((file = e.target.files.item(i))) {\n                        files.push({ name: file.name, file });\n                    }\n                }\n                node.input(files);\n            }\n            if (node.context)\n                node.context.files = files;\n            // Call the original listener if there is one.\n            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {\n                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);\n            }\n        };\n    });\n}\n\n/**\n * Handle the submit event.\n * @param e - The event\n * @public\n */\nasync function handleSubmit(node, submitEvent) {\n    submitEvent.preventDefault();\n    await node.settled;\n    // Set the submitted state on all children\n    node.walk((n) => {\n        n.store.set(createMessage({\n            key: 'submitted',\n            value: true,\n            visible: false,\n        }));\n    });\n    if (typeof node.props.onSubmitRaw === 'function') {\n        node.props.onSubmitRaw(submitEvent, node);\n    }\n    if (node.ledger.value('blocking')) {\n        // There is still a blocking message in the store.\n        if (node.props.incompleteMessage !== false) {\n            node.store.set(createMessage({\n                blocking: false,\n                key: `incomplete`,\n                meta: {\n                    localize: node.props.incompleteMessage === undefined,\n                    i18nArgs: [{ node }],\n                    showAsMessage: true,\n                },\n                type: 'ui',\n                value: node.props.incompleteMessage || 'Form incomplete.',\n            }));\n        }\n    }\n    else {\n        // No blocking messages\n        if (typeof node.props.onSubmit === 'function') {\n            // call onSubmit\n            const retVal = node.props.onSubmit(node.hook.submit.dispatch(clone(node.value)), node);\n            if (retVal instanceof Promise) {\n                const autoDisable = node.props.disabled === undefined &&\n                    node.props.submitBehavior !== 'live';\n                if (autoDisable)\n                    node.props.disabled = true;\n                node.store.set(createMessage({\n                    key: 'loading',\n                    value: true,\n                    visible: false,\n                }));\n                await retVal;\n                if (autoDisable)\n                    node.props.disabled = false;\n                node.store.remove('loading');\n            }\n        }\n        else {\n            if (submitEvent.target instanceof HTMLFormElement) {\n                submitEvent.target.submit();\n            }\n        }\n    }\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction form$1(node) {\n    node.props.isForm = true;\n    node.on('created', () => {\n        var _a;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.submit = handleSubmit.bind(null, node);\n        }\n        if (!has(node.props, 'actions')) {\n            node.props.actions = true;\n        }\n    });\n    node.on('settled:blocking', () => node.store.remove('incomplete'));\n}\n\n/**\n * Applies ignore=\"true\" by default.\n * @param node - The node\n * @public\n */\nfunction ignore(node) {\n    if (node.props.ignore === undefined) {\n        node.props.ignore = true;\n        node.parent = null;\n    }\n}\n\n/**\n * Ensures the input has an `initialValue` prop.\n * @param node - The node being given an initial value\n * @public\n */\nfunction initialValue(node) {\n    node.on('created', () => {\n        if (node.context) {\n            node.context.initialValue = node.value || '';\n        }\n    });\n}\n\n/**\n * Sets the value of a radio button when checked.\n * @param node - FormKitNode\n * @param value - Value\n * @public\n */\nfunction toggleChecked(node, event) {\n    if (event.target instanceof HTMLInputElement) {\n        node.input(optionValue(node.props.options, event.target.value));\n    }\n}\n/**\n * Checks if the value being checked is the current value.\n * @param node - The node to check against.\n * @param value - The value to check\n * @returns\n */\nfunction isChecked(node, value) {\n    var _a, _b;\n    // We need to force vue\u2019s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    return shouldSelect(optionValue(node.props.options, value), node._value);\n}\n/**\n * Determines if a given radio input is being evaluated.\n * @param node - The radio input group.\n * @public\n */\nfunction radios(node) {\n    node.on('created', () => {\n        var _a, _b;\n        if (!Array.isArray(node.props.options)) {\n            warn(350, node);\n        }\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked.bind(null, node);\n        }\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Checks if a the given option should have the selected attribute.\n * @param node - The node being evaluated.\n * @param option - The option value to check\n * @returns\n * @public\n */\nfunction isSelected(node, option) {\n    // Here we trick reactivity (if at play) to watch this function.\n    node.context && node.context.value;\n    const value = optionValue(node.props.options, option);\n    return Array.isArray(node._value)\n        ? node._value.some((optionA) => shouldSelect(optionA, value))\n        : (node.value === undefined && !option) || shouldSelect(value, node._value);\n}\n/**\n * Select the correct values.\n * @param e - The input event emitted by the select.\n */\nfunction selectInput(node, e) {\n    const target = e.target;\n    const value = target.hasAttribute('multiple')\n        ? Array.from(target.selectedOptions).map((o) => optionValue(node.props.options, o.value))\n        : optionValue(node.props.options, target.value);\n    node.input(value);\n}\n/**\n * Appends a placeholder to the options list.\n * @param options - An options list\n * @param placeholder - A placeholder string to append\n * @returns\n */\nfunction applyPlaceholder(options, placeholder) {\n    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {\n        return [\n            {\n                label: placeholder,\n                value: '',\n                attrs: {\n                    hidden: true,\n                    disabled: true,\n                    'data-is-placeholder': 'true',\n                },\n            },\n            ...options,\n        ];\n    }\n    return options;\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction select$1(node) {\n    // Set the initial value of a multi-input\n    node.on('created', () => {\n        var _a, _b, _c;\n        const isMultiple = undefine((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple);\n        if (!isMultiple &&\n            node.props.placeholder &&\n            Array.isArray(node.props.options)) {\n            node.hook.prop(({ prop, value }, next) => {\n                if (prop === 'options') {\n                    value = applyPlaceholder(value, node.props.placeholder);\n                }\n                return next({ prop, value });\n            });\n            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);\n        }\n        if (isMultiple) {\n            if (node.value === undefined) {\n                node.input([], false);\n            }\n        }\n        else if (node.context && !node.context.options) {\n            // If this input is (probably) using the default slot, we need to add a\n            // \"value\" attribute to get bound\n            node.props.attrs = Object.assign({}, node.props.attrs, {\n                value: node._value,\n            });\n            node.on('input', ({ payload }) => {\n                node.props.attrs = Object.assign({}, node.props.attrs, {\n                    value: payload,\n                });\n            });\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {\n            node.context.handlers.selectInput = selectInput.bind(null, node);\n        }\n        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {\n            node.context.fns.isSelected = isSelected.bind(null, node);\n        }\n    });\n    node.hook.input((value, next) => {\n        var _a, _b, _c;\n        if (!node.props.placeholder &&\n            value === undefined &&\n            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&\n            node.props.options.length &&\n            !undefine((_c = (_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.multiple)) {\n            value =\n                '__original' in node.props.options[0]\n                    ? node.props.options[0].__original\n                    : node.props.options[0].value;\n        }\n        return next(value);\n    });\n}\n\n/**\n * @param sectionKey - the location the icon should be loaded\n * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS\n * @public\n */\nfunction defaultIcon(sectionKey, defaultIcon) {\n    return (node) => {\n        if (node.props[`${sectionKey}Icon`] === undefined) {\n            node.props[`${sectionKey}Icon`] = `default:${defaultIcon}`;\n        }\n    };\n}\n\n/**\n * Type guard for schema objects.\n * @param schema - returns true if the node is a schema node but not a string or conditional.\n */\nfunction isSchemaObject(schema) {\n    return (typeof schema === 'object' &&\n        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));\n}\n/**\n * Checks if the current schema node is a slot condition like:\n * ```js\n * {\n *  if: '$slot.name',\n *  then: '$slot.name',\n *  else: []\n * }\n * ```\n * @param node - a schema node\n * @returns\n */\nfunction isSlotCondition(node) {\n    if (isConditional(node) &&\n        node.if &&\n        node.if.startsWith('$slots.') &&\n        typeof node.then === 'string' &&\n        node.then.startsWith('$slots.') &&\n        'else' in node) {\n        return true;\n    }\n    return false;\n}\n/**\n * Extends a single schema node with an extension. The extension can be any partial node including strings.\n * @param schema - Extend a base schema node.\n * @param extension - The values to extend on the base schema node.\n * @returns\n * @public\n */\nfunction extendSchema(schema, extension = {}) {\n    if (typeof schema === 'string') {\n        return isSchemaObject(extension) || typeof extension === 'string'\n            ? extension\n            : schema;\n    }\n    else if (Array.isArray(schema)) {\n        return isSchemaObject(extension) ? extension : schema;\n    }\n    return extend(schema, extension);\n}\n/**\n * ================================================================\n * NOTE: This function is deprecated. Use `createSection` instead!\n * ================================================================\n *\n * @param key - A new section key name.\n * @param schema - The default schema in this composable slot.\n * @returns\n * @public\n */\nfunction composable(key, schema) {\n    warn(800, 'composable function');\n    return (extendWith = {}, children = undefined) => {\n        const root = typeof schema === 'function'\n            ? schema(children)\n            : typeof schema === 'object'\n                ? clone(schema)\n                : schema;\n        const isObj = isSchemaObject(root);\n        if (isObj && !('children' in root) && children) {\n            if (Array.isArray(children)) {\n                if (children.length) {\n                    root.children = children;\n                }\n            }\n            else {\n                root.children = [children];\n            }\n        }\n        const extended = extendSchema(root, extendWith);\n        return {\n            if: `$slots.${key}`,\n            then: `$slots.${key}`,\n            else: Array.isArray(extended) ? extended : [extended],\n        };\n    };\n}\n/**\n * Creates an input schema with all of the wrapping base schema.\n * @param inputSchema - Content to store in the input section key location.\n * @public\n */\nfunction useSchema(inputSection) {\n    return outer(wrapper(label('$label'), inner(prefix(), inputSection(), suffix())), help('$help'), messages(message('$message.value')));\n}\n/**\n * Creates a new reusable section.\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When true returns an extendable root schema node.\n * @returns\n * @public\n */\nfunction createSection(section, el, root = false) {\n    return (...children) => {\n        const extendable = (extensions) => {\n            const node = !el || typeof el === 'string' ? { $el: el } : el();\n            if (isDOM(node) || isComponent(node)) {\n                if (!node.meta) {\n                    node.meta = { section };\n                }\n                if (children.length && !node.children) {\n                    node.children = [\n                        ...children.map((child) => typeof child === 'string' ? child : child(extensions)),\n                    ];\n                }\n                if (isDOM(node)) {\n                    node.attrs = {\n                        class: `$classes.${section}`,\n                        ...(node.attrs || {}),\n                    };\n                }\n            }\n            return {\n                if: `$slots.${section}`,\n                then: `$slots.${section}`,\n                else: section in extensions\n                    ? extendSchema(node, extensions[section])\n                    : node,\n            };\n        };\n        return root ? createRoot(extendable) : extendable;\n    };\n}\n/**\n * Returns an extendable schema root node.\n * @param rootSection - Creates the root node.\n * @returns\n */\nfunction createRoot(rootSection) {\n    return (extensions) => {\n        return [rootSection(extensions)];\n    };\n}\n/**\n * Applies attributes to a given schema section by applying a higher order\n * function that merges a given set of attributes into the node.\n * @param attrs - Apply attributes to a FormKitSchemaExtendableSection\n * @param section - A section to apply attributes to\n * @returns\n * @public\n */\nfunction $attrs(attrs, section) {\n    return (extensions) => {\n        const node = section(extensions);\n        const attributes = typeof attrs === 'function' ? attrs() : attrs;\n        if (!isObject(attributes))\n            return node;\n        if (isSlotCondition(node) && isDOM(node.else)) {\n            node.else.attrs = { ...node.else.attrs, ...attributes };\n        }\n        else if (isDOM(node)) {\n            node.attrs = { ...node.attrs, ...attributes };\n        }\n        return node;\n    };\n}\n/**\n *\n * @param condition - A schema condition to apply to a section.\n * @param then - The section that applies if the condition is true.\n * @param otherwise - (else) The section that applies if the condition is false.\n * @returns\n * @public\n */\nfunction $if(condition, then, otherwise) {\n    return (extensions) => {\n        const node = then(extensions);\n        if (otherwise) {\n            return {\n                if: condition,\n                then: node,\n                else: otherwise(extensions),\n            };\n        }\n        else if (isSlotCondition(node)) {\n            Object.assign(node.else, { if: condition });\n        }\n        else if (isSchemaObject(node)) {\n            Object.assign(node, { if: condition });\n        }\n        return node;\n    };\n}\n/**\n * Applies a condition to a given schema section.\n * @param varName - The name of the variable that holds the current instance.\n * @param inName - The variable we are iterating over.\n * @param section - A section to repeat\n * @returns\n * @public\n */\nfunction $for(varName, inName, section) {\n    return (extensions) => {\n        const node = section(extensions);\n        if (isSlotCondition(node)) {\n            Object.assign(node.else, { for: `${varName} in ${inName}` });\n        }\n        else if (isSchemaObject(node)) {\n            Object.assign(node, { for: `${varName} in ${inName}` });\n        }\n        return node;\n    };\n}\n/**\n * Extends a schema node with a given set of extensions.\n * @param section - A section to apply an extension to.\n * @param extendWith - A partial schema snippet to apply to the section.\n * @returns\n * @public\n */\nfunction $extend(section, extendWith) {\n    return (extensions) => {\n        const node = section({});\n        if (isSlotCondition(node)) {\n            if (Array.isArray(node.else))\n                return node;\n            node.else = extendSchema(extendSchema(node.else, extendWith), extensions);\n            return node;\n        }\n        return extendSchema(extendSchema(node, extendWith), extensions);\n    };\n}\n/**\n * Creates a root schema section.\n * @param section - A section to make a root from.\n * @returns\n * @public\n */\nfunction $root(section) {\n    return createRoot(section);\n}\n\n/**\n * Input definition for a button.\n * @public\n */\nconst button = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(messages(message('$message.value')), wrapper(buttonInput(icon('prefix'), prefix(), buttonLabel('$label || $ui.submit.value'), suffix(), icon('suffix'))), help('$help')),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [localize('submit'), ignore],\n};\n\n/**\n * Input definition for a checkbox(ess).\n * @public\n */\nconst checkbox = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer($if('$options == undefined', \n    /**\n     * Single checkbox structure.\n     */\n    boxWrapper(inner(prefix(), box(), decorator(), suffix()), $if('$label', boxLabel('$label'))), \n    /**\n     * Multi checkbox structure.\n     */\n    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {\n        bind: '$option.attrs',\n        attrs: {\n            id: '$option.attrs.id',\n            value: '$option.value',\n            checked: '$fns.isChecked($option.value)',\n        },\n    }), decorator(), suffix()), $if('$option.label', boxLabel('$option.label'))), boxHelp('$option.help'))))), \n    // Help text only goes under the input when it is a single.\n    $if('$options.length === 0 && $help', help('$help')), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: ['options', 'onValue', 'offValue'],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [options, checkboxes],\n};\n\n/**\n * Input definition for a file input.\n * @public\n */\nconst file = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), fileInput(), fileList(fileItem(icon('fileItem'), fileName('$file.name'), $if('$value.length === 1', fileRemove(icon('fileRemove'), '$ui.remove.value')))), $if('$value.length > 1', fileRemove('$ui.removeAll.value')), noFiles(icon('fileItem'), '$ui.noFiles.value'), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [\n        files,\n        defaultIcon('fileItem', 'fileDoc'),\n        defaultIcon('fileRemove', 'close'),\n    ],\n};\n\n/**\n * Input definition for a form.\n * @public\n */\nconst form = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: formInput('$slots.default', messages(message('$message.value')), actions(submitInput())),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'group',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [\n        'actions',\n        'submit',\n        'submitLabel',\n        'submitAttrs',\n        'submitBehavior',\n        'incompleteMessage',\n    ],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [form$1, disables],\n};\n\n/**\n * Input definition for a group.\n * @public\n */\nconst group = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: fragment('$slots.default'),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'group',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [disables],\n};\n\n/**\n * Input definition for a hidden input.\n * @public\n */\nconst hidden = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: $root(textInput()),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [],\n};\n\n/**\n * Input definition for a list.\n * @public\n */\nconst list = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: fragment('$slots.default'),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'list',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [disables],\n};\n\n/**\n * Input definition for a radio.\n * @public\n */\nconst radio = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer($if('$options == undefined', \n    /**\n     * Single radio structure.\n     */\n    boxWrapper(inner(prefix(), box(), decorator(), suffix()), $if('$label', boxLabel('$label'))), \n    /**\n     * Multi radio structure.\n     */\n    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {\n        bind: '$option.attrs',\n        attrs: {\n            id: '$option.attrs.id',\n            value: '$option.value',\n            checked: '$fns.isChecked($option.value)',\n        },\n    }), decorator(), suffix()), $if('$option.label', boxLabel('$option.label'))), boxHelp('$option.help'))))), \n    // Help text only goes under the input when it is a single.\n    $if('$options.length === 0 && $help', help('$help')), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: ['options', 'onValue', 'offValue'],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [options, radios],\n};\n\n/**\n * Input definition for a select.\n * @public\n */\nconst select = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix'), prefix(), selectInput$1($if('$slots.default', () => '$slots.default', $if('$slots.option', optionSlot, option('$option.label')))), icon('select'), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: ['options', 'placeholder'],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [options, select$1, defaultIcon('select', 'down')],\n};\n\n/**\n * Input definition for a textarea.\n * @public\n */\nconst textarea = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textareaInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [initialValue],\n};\n\n/**\n * Input definition for a text.\n * @public\n */\nconst text = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [],\n};\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    button: button,\n    submit: button,\n    checkbox: checkbox,\n    file: file,\n    form: form,\n    group: group,\n    hidden: hidden,\n    list: list,\n    radio: radio,\n    select: select,\n    textarea: textarea,\n    text: text,\n    color: text,\n    date: text,\n    datetimeLocal: text,\n    email: text,\n    month: text,\n    number: text,\n    password: text,\n    search: text,\n    tel: text,\n    time: text,\n    url: text,\n    week: text,\n    range: text\n});\n\nexport { $attrs, $extend, $for, $if, $root, actions, box, boxHelp, boxLabel, boxOption, boxOptions, boxWrapper, button, buttonInput, buttonLabel, checkbox, checkboxes, text as color, composable, createLibraryPlugin, createSection, text as date, text as datetimeLocal, decorator, defaultIcon, disables as disablesChildren, text as email, extendSchema, fieldset, file, fileInput, fileItem, fileList, fileName, fileRemove, files, form, formInput, form$1 as forms, fragment, group, help, hidden, icon, ignore as ignores, initialValue, inner, index as inputs, label, legend, list, localize, message, messages, text as month, noFiles, normalizeBoxes, text as number, option, optionSlot, options, outer, text as password, prefix, radio, radios, text as range, text as search, select, selectInput$1 as selectInput, select$1 as selects, button as submit, submitInput, suffix, text as tel, text, textInput, textarea, textareaInput, text as time, text as url, useSchema, text as week, wrapper };\n", "import { has, regexForFormat, eq, empty } from '@formkit/utils';\n\n/**\n * Determine if the given input's value was should be considered \"accepted\".\n * @param context - The FormKitValidationContext\n * @public\n */\nconst accepted = function accepted({ value }) {\n    return ['yes', 'on', '1', 1, true, 'true'].includes(value);\n};\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue > timestamp;\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u010C\u010D\u010E\u010F\u0118\u0119\u011A\u011B\u0141\u0142\u0143\u0144\u0147\u0148\u0158\u0159\u015A\u015B\u0160\u0161\u0164\u0165\u016E\u016F\u0179\u017A\u017B\u017D\u017E\u017C]+$/,\n        latin: /^[a-zA-Z]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha_spaces = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u010C\u010D\u010E\u010F\u0118\u0119\u011A\u011B\u0141\u0142\u0143\u0144\u0147\u0148\u0158\u0159\u015A\u015B\u0160\u0161\u0164\u0165\u016E\u016F\u0179\u017A\u017B\u017D\u017E\u017C ]+$/,\n        latin: /^[a-zA-Z ]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alphanumeric = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\u015A\u015B\u0179\u017A\u017B\u017C]+$/,\n        latin: /^[a-zA-Z0-9]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value before a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue < timestamp;\n};\n\n/**\n * Determine if the given input's value is between two other values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst between = function between({ value }, from, to) {\n    if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {\n        const val = 1 * value;\n        from = Number(from);\n        to = Number(to);\n        const [a, b] = from <= to ? [from, to] : [to, from];\n        return val >= 1 * a && val <= 1 * b;\n    }\n    return false;\n};\n\nconst hasConfirm = /(_confirm(?:ed)?)$/;\n/**\n * Determine if the given input's value matches another input's value\n * @param context - The FormKitValidationContext\n * @public\n */\nconst confirm = function confirm(node, address, comparison = 'loose') {\n    var _a;\n    if (!address) {\n        address = hasConfirm.test(node.name)\n            ? node.name.replace(hasConfirm, '')\n            : `${node.name}_confirm`;\n    }\n    const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;\n    return comparison === 'strict'\n        ? node.value === foreignValue\n        : node.value == foreignValue;\n};\n\n/**\n * Determine if the given input's value is between two other dates\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_between = function date_between({ value }, dateA, dateB) {\n    dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);\n    dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);\n    const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));\n    if (dateA && !dateB) {\n        dateB = dateA;\n        dateA = Date.now();\n    }\n    else if (!dateA || !compareTo) {\n        return false;\n    }\n    return compareTo >= dateA && compareTo <= dateB;\n};\n\n/**\n * Determine if the given input's value matches a specified date format\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_format = function date({ value }, format) {\n    if (format && typeof format === 'string') {\n        return regexForFormat(format).test(String(value));\n    }\n    return !isNaN(Date.parse(String(value)));\n};\n\n/**\n * Determine if the given input's value is a plausible email address.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst email = function email({ value }) {\n    const isEmail = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n    return isEmail.test(String(value));\n};\n\n/**\n * Determine if the given input's value ends with a given string\n * @param context - The FormKitValidationContext\n * @public\n */\nconst ends_with = function ends_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.endsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is in a set of possible values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst is = function is({ value }, ...stack) {\n    return stack.some((item) => {\n        if (typeof item === 'object') {\n            return eq(item, value);\n        }\n        return item == value;\n    });\n};\n\n/**\n * Determine if the given input's value length is full width.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst length = function length({ value }, first = 0, second = Infinity) {\n    first = parseInt(first);\n    second = isNaN(parseInt(second)) ? Infinity : parseInt(second);\n    const min = first <= second ? first : second;\n    const max = second >= first ? second : first;\n    if (typeof value === 'string' || Array.isArray(value)) {\n        return value.length >= min && value.length <= max;\n    }\n    else if (value && typeof value === 'object') {\n        const length = Object.keys(value).length;\n        return length >= min && length <= max;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value matches one or more values or regular expressions.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst matches = function matches({ value }, ...stack) {\n    return stack.some((pattern) => {\n        if (typeof pattern === 'string' &&\n            pattern.substr(0, 1) === '/' &&\n            pattern.substr(-1) === '/') {\n            pattern = new RegExp(pattern.substr(1, pattern.length - 2));\n        }\n        if (pattern instanceof RegExp) {\n            return pattern.test(String(value));\n        }\n        return pattern === value;\n    });\n};\n\n/**\n * Determine if the given input's value is less than the maximum\n * @param context - The FormKitValidationContext\n * @public\n */\nconst max = function max({ value }, maximum = 10) {\n    if (Array.isArray(value)) {\n        return value.length <= maximum;\n    }\n    return Number(value) <= Number(maximum);\n};\n\n/**\n * Determine if the given input's value is less than a certain value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst min = function min({ value }, minimum = 1) {\n    if (Array.isArray(value)) {\n        return value.length >= minimum;\n    }\n    return Number(value) >= Number(minimum);\n};\n\n/**\n * Determine if the given input's value is not in a given stack\n * @param context - The FormKitValidationContext\n * @public\n */\nconst not = function not({ value }, ...stack) {\n    return !stack.some((item) => {\n        if (typeof item === 'object') {\n            return eq(item, value);\n        }\n        return item === value;\n    });\n};\n\n/**\n * Determine if the given input's value is numeric\n * @param context - The FormKitValidationContext\n * @public\n */\nconst number = function number({ value }) {\n    return !isNaN(value);\n};\n\n/**\n * Determine if the given input's value was required.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst required = function required({ value }, action = 'default') {\n    return action === 'trim' && typeof value === 'string'\n        ? !empty(value.trim())\n        : !empty(value);\n};\n/**\n * This rules should run even if the inputs is empty (obviously)\n */\nrequired.skipEmpty = false;\n\n/**\n * Determine if the given input's value starts with a substring\n * @param context - The FormKitValidationContext\n * @public\n */\nconst starts_with = function starts_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.startsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is an http url\n * @param context - The FormKitValidationContext\n * @public\n */\nconst url = function url({ value }, ...stack) {\n    try {\n        const protocols = stack.length ? stack : ['http:', 'https:'];\n        const url = new URL(String(value));\n        return protocols.includes(url.protocol);\n    }\n    catch {\n        return false;\n    }\n};\n\nexport { accepted, alpha, alpha_spaces, alphanumeric, between, confirm, date_after, date_before, date_between, date_format, email, ends_with, is, length, matches, max, min, not, number, required, starts_with, url };\n", "import { has } from '@formkit/utils';\nimport { isNode } from '@formkit/core';\n\n/**\n * A registry of all revoked observers.\n */\nconst revokedObservers = new WeakSet();\n/**\n * The FormKitNode to observe.\n * @param node - Any formkit node to observe.\n * @returns\n * @public\n */\nfunction createObserver(node, dependencies) {\n    // The dependencies touched during tracking\n    const deps = dependencies || Object.assign(new Map(), { active: false });\n    // A registry of event receipts returned by the event system\n    const receipts = new Map();\n    /**\n     * Simple function to add a dependency to the deps map.\n     * @param event - The name of the event type (like commit/input etc)\n     */\n    const addDependency = function (event) {\n        var _a;\n        if (!deps.active)\n            return;\n        if (!deps.has(node))\n            deps.set(node, new Set());\n        (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);\n    };\n    /**\n     * Proxies the props of a node so we know which ones were messed with, could\n     * potentially be more generalized in the future if we want to support\n     * more sub-objects.\n     * @param props - The props object from a node\n     * @returns\n     */\n    const observeProps = function (props) {\n        return new Proxy(props, {\n            get(...args) {\n                typeof args[1] === 'string' && addDependency(`prop:${args[1]}`);\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Observes the FormKit ledger \"value\".\n     * @param ledger - A formkit ledger counter.\n     */\n    const observeLedger = function (ledger) {\n        return new Proxy(ledger, {\n            get(...args) {\n                if (args[1] === 'value') {\n                    return (key) => {\n                        addDependency(`count:${key}`);\n                        return ledger.value(key);\n                    };\n                }\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Return values from our observer proxy first pass through this function\n     * which gives us a chance to listen sub-dependencies and properties.\n     */\n    const observe = function (value, property) {\n        if (isNode(value)) {\n            return createObserver(value, deps);\n        }\n        if (property === 'value')\n            addDependency('commit');\n        if (property === 'props')\n            return observeProps(value);\n        if (property === 'ledger')\n            return observeLedger(value);\n        return value;\n    };\n    /**\n     * The actual proxy object of the original node.\n     */\n    const { proxy: observed, revoke, } = Proxy.revocable(node, {\n        get(...args) {\n            switch (args[1]) {\n                case 'deps':\n                    return deps;\n                case 'watch':\n                    return (block) => watch(observed, block);\n                case 'observe':\n                    return () => {\n                        const old = new Map(deps);\n                        deps.clear();\n                        deps.active = true;\n                        return old;\n                    };\n                case 'stopObserve':\n                    return () => {\n                        const newDeps = new Map(deps);\n                        deps.active = false;\n                        return newDeps;\n                    };\n                case 'receipts':\n                    return receipts;\n                case 'kill':\n                    return () => {\n                        removeListeners(receipts);\n                        revokedObservers.add(args[2]);\n                        revoke();\n                    };\n            }\n            const value = Reflect.get(...args);\n            // If we're dealing with a function, we need to sub-call the function\n            // get that return value, and pass it through the same logic.\n            if (typeof value === 'function') {\n                return (...subArgs) => {\n                    const subValue = value(...subArgs);\n                    return observe(subValue, args[1]);\n                };\n            }\n            return observe(value, args[1]);\n        },\n    });\n    return observed;\n}\n/**\n * Given two maps (toAdd and toRemove) apply the dependencies as event listeners\n * on the underlying nodes.\n * @param node - The node to apply dependencies to\n * @param delta - The toAdd and toRemove dependency Maps\n * @public\n */\nfunction applyListeners(node, [toAdd, toRemove], callback) {\n    toAdd.forEach((events, depNode) => {\n        events.forEach((event) => {\n            node.receipts.has(depNode) || node.receipts.set(depNode, {});\n            node.receipts.set(depNode, Object.assign(node.receipts.get(depNode), {\n                [event]: depNode.on(event, callback),\n            }));\n        });\n    });\n    toRemove.forEach((events, depNode) => {\n        events.forEach((event) => {\n            if (node.receipts.has(depNode)) {\n                const nodeReceipts = node.receipts.get(depNode);\n                if (nodeReceipts && has(nodeReceipts, event)) {\n                    depNode.off(nodeReceipts[event]);\n                    delete nodeReceipts[event];\n                    node.receipts.set(depNode, nodeReceipts);\n                }\n            }\n        });\n    });\n}\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The formkit observer receipts to remove\n * @public\n */\nfunction removeListeners(receipts) {\n    receipts.forEach((events, node) => {\n        for (const event in events) {\n            node.off(events[event]);\n        }\n    });\n}\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @public\n */\nasync function watch(node, block) {\n    const oldDeps = new Map(node.deps);\n    node.observe();\n    const res = block(node);\n    if (res instanceof Promise)\n        await res;\n    const newDeps = node.stopObserve();\n    applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block));\n}\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies\n * @param current - The new/current watcher dependencies\n * @returns\n * @public\n */\nfunction diffDeps(previous, current) {\n    const toAdd = new Map();\n    const toRemove = new Map();\n    current.forEach((events, node) => {\n        if (!previous.has(node)) {\n            toAdd.set(node, events);\n        }\n        else {\n            const eventsToAdd = new Set();\n            const previousEvents = previous.get(node);\n            events.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));\n            toAdd.set(node, eventsToAdd);\n        }\n    });\n    previous.forEach((events, node) => {\n        if (!current.has(node)) {\n            toRemove.set(node, events);\n        }\n        else {\n            const eventsToRemove = new Set();\n            const newEvents = current.get(node);\n            events.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));\n            toRemove.set(node, eventsToRemove);\n        }\n    });\n    return [toAdd, toRemove];\n}\n/**\n * Checks if the given noe is revoked.\n * @param node - Any observed node to check.\n * @returns\n * @public\n */\nfunction isKilled(node) {\n    return revokedObservers.has(node);\n}\n\nexport { applyListeners, createObserver, diffDeps, isKilled, removeListeners };\n", "import { createMessage } from '@formkit/core';\nimport { createObserver, removeListeners, isKilled, applyListeners, diffDeps } from '@formkit/observer';\nimport { token, cloneAny, eq, empty, clone, has } from '@formkit/utils';\n\n/**\n * Message that gets set when the node is awaiting validation.\n */\nconst validatingMessage = createMessage({\n    type: 'state',\n    blocking: true,\n    visible: false,\n    value: true,\n    key: 'validating',\n});\n/**\n * The actual validation plugin function, everything must be bootstrapped here.\n * @param node - The node to bind validation to.\n * @public\n */\nfunction createValidationPlugin(baseRules = {}) {\n    return function validationPlugin(node) {\n        const availableRules = Object.assign({}, baseRules, node.props.validationRules);\n        // create an observed node\n        let observedNode = createObserver(node);\n        const state = { input: token(), rerun: null, isPassing: true };\n        let validation = cloneAny(node.props.validation);\n        // If the node's validation prop changes, update the rules:\n        node.on('prop:validation', ({ payload: value }) => {\n            if (eq(validation, value))\n                return;\n            validation = cloneAny(value);\n            // Destroy all observers that may re-trigger validation on an old stack\n            removeListeners(observedNode.receipts);\n            // Remove all existing messages before re-validating\n            node.store.filter(() => false, 'validation');\n            node.props.parsedRules = parseRules(value, availableRules);\n            observedNode.kill();\n            observedNode = createObserver(node);\n            validate(observedNode, node.props.parsedRules, state);\n        });\n        // Validate the field when this plugin is initialized\n        node.props.parsedRules = parseRules(validation, availableRules);\n        validate(observedNode, node.props.parsedRules, state);\n    };\n}\n/**\n * Given parsed validations, a value and a node, run the validations and set\n * the appropriate store messages on the node.\n * @param value - The value being validated\n * @param node - The Node this value belongs to\n * @param rules - The rules\n */\nfunction validate(node, validations, state) {\n    if (isKilled(node))\n        return;\n    state.input = token();\n    state.isPassing = true;\n    node.store.filter((message) => !message.meta.removeImmediately, 'validation');\n    validations.forEach((validation) => validation.debounce && clearTimeout(validation.timer));\n    if (validations.length) {\n        node.store.set(validatingMessage);\n        run(0, validations, node, state, false, () => {\n            node.store.remove(validatingMessage.key);\n        });\n    }\n}\n/**\n * Runs validation rules recursively while collecting dependencies allowing for\n * cross-node validation rules that automatically re-trigger when a foreign\n * value is changed.\n * @param current - The index of the current validation rule\n * @param validations - The remaining validation rule stack to run\n * @param node - An observed node, the owner of this validation stack\n * @param state - An object of state information about this run\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\n * @returns\n */\nfunction run(current, validations, node, state, removeImmediately, complete) {\n    const validation = validations[current];\n    if (!validation)\n        return complete();\n    const currentRun = state.input;\n    validation.state = null;\n    function next(async, result) {\n        state.isPassing = state.isPassing && !!result;\n        validation.queued = false;\n        const newDeps = node.stopObserve();\n        applyListeners(node, diffDeps(validation.deps, newDeps), () => {\n            validation.queued = true;\n            if (state.rerun)\n                clearTimeout(state.rerun);\n            state.rerun = setTimeout(validate, 0, node, validations, state);\n        });\n        validation.deps = newDeps;\n        if (state.input === currentRun) {\n            validation.state = result;\n            if (result === false) {\n                createFailedMessage(node, validation, removeImmediately || async);\n            }\n            else {\n                removeMessage(node, validation);\n            }\n            if (validations.length > current + 1) {\n                run(current + 1, validations, node, state, removeImmediately || async, complete);\n            }\n            else {\n                // The validation has completed\n                complete();\n            }\n        }\n    }\n    if ((!empty(node.value) || !validation.skipEmpty) &&\n        (state.isPassing || validation.force)) {\n        if (validation.queued) {\n            runRule(validation, node, (result) => {\n                result instanceof Promise\n                    ? result.then((r) => next(true, r))\n                    : next(false, result);\n            });\n        }\n        else {\n            // In this case our rule is not queued, so literally nothing happened that\n            // would affect it, we just need to move past this rule and make no\n            // modifications to state\n            run(current + 1, validations, node, state, removeImmediately, complete);\n        }\n    }\n    else {\n        // This rule is not being run because either:\n        //  1. The field is empty and this rule should not run when empty\n        //  2. A previous validation rule is failing and this one is not forced\n        // In this case we should call next validation.\n        if (empty(node.value) && validation.skipEmpty && state.isPassing) {\n            // This node has an empty value so its validation was skipped. So we\n            // need to queue it up, we do that by starting an observation and just\n            // touching the value attribute.\n            node.observe();\n            node.value;\n        }\n        next(false, null);\n    }\n}\n/**\n * Run a validation rule debounced or not.\n * @param validation - A validation to debounce\n */\nfunction runRule(validation, node, after) {\n    if (validation.debounce) {\n        validation.timer = setTimeout(() => {\n            node.observe();\n            after(validation.rule(node, ...validation.args));\n        }, validation.debounce);\n    }\n    else {\n        node.observe();\n        after(validation.rule(node, ...validation.args));\n    }\n}\n/**\n * The messages given to this function have already been set on the node, but\n * any other validation messages on the node that are not included in this\n * stack should be removed because they have been resolved.\n * @param node - The node to operate on.\n * @param messages - A new stack of messages\n */\nfunction removeMessage(node, validation) {\n    const key = `rule_${validation.name}`;\n    if (has(node.store, key)) {\n        node.store.remove(key);\n    }\n}\n/**\n *\n * @param value - The value that is failing\n * @param validation - The validation object\n */\nfunction createFailedMessage(node, validation, removeImmediately) {\n    const i18nArgs = createI18nArgs(node, validation);\n    const customMessage = createCustomMessage(node, validation, i18nArgs);\n    // Here we short circuit the i18n system to force the output.\n    const message = createMessage({\n        blocking: validation.blocking,\n        key: `rule_${validation.name}`,\n        meta: {\n            /**\n             * Use this key instead of the message root key to produce i18n validation\n             * messages.\n             */\n            messageKey: validation.name,\n            /**\n             * For messages that were created *by or after* a debounced or async\n             * validation rule \u2014 we make note of it so we can immediately remove them\n             * as soon as the next commit happens.\n             */\n            removeImmediately,\n            /**\n             * Determines if this message should be passed to localization.\n             */\n            localize: !customMessage,\n            /**\n             * The arguments that will be passed to the validation rules\n             */\n            i18nArgs,\n        },\n        type: 'validation',\n        value: customMessage || 'This field is not valid.',\n    });\n    node.store.set(message);\n    return message;\n}\n/**\n * Returns a custom validation message if applicable.\n * @param node - FormKit Node\n * @param validation - The validation rule being processed.\n */\nfunction createCustomMessage(node, validation, i18nArgs) {\n    const customMessage = node.props.validationMessages &&\n        has(node.props.validationMessages, validation.name)\n        ? node.props.validationMessages[validation.name]\n        : undefined;\n    if (typeof customMessage === 'function') {\n        return customMessage(...i18nArgs);\n    }\n    return customMessage;\n}\n/**\n * Creates the arguments passed to the i18n\n * @param node - The node that performed the validation\n * @param validation - The validation that failed\n */\nfunction createI18nArgs(node, validation) {\n    // If a custom message has been found, short circuit the i18n system.\n    return [\n        {\n            node,\n            name: createMessageName(node),\n            args: validation.args,\n        },\n    ];\n}\n/**\n * The name used in validation messages.\n * @param node - The node to display\n * @returns\n */\nfunction createMessageName(node) {\n    if (typeof node.props.validationLabel === 'function') {\n        return node.props.validationLabel(node);\n    }\n    return (node.props.validationLabel ||\n        node.props.label ||\n        node.props.name ||\n        String(node.name));\n}\n/**\n * Describes hints, must also be changed in the debounceExtractor.\n */\nconst hintPattern = '(?:[\\\\*+?()0-9]+)';\n/**\n * A pattern to describe rule names. Rules names can only contain letters,\n * numbers, and underscores and must start with a letter.\n */\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+';\n/**\n * Regular expression for extracting rule data.\n */\nconst ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`, 'i');\n/**\n * Validation hints are special characters preceding a validation rule, like\n * !phone\n */\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i');\n/**\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\n * matches.\n */\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\n/**\n * Determines if a given string is in the proper debounce format.\n */\nconst hasDebounce = /\\(\\d+\\)/;\n/**\n * The default values of the available validation hints.\n */\nconst defaultHints = {\n    blocking: true,\n    debounce: 0,\n    force: false,\n    skipEmpty: true,\n    name: '',\n};\n/**\n * Parse validation intents and strings into validation rule stacks.\n * @param validation - Either a string a validation rules, or proper array of structured rules.\n * @internal\n */\nfunction parseRules(validation, rules) {\n    if (!validation)\n        return [];\n    const intents = typeof validation === 'string'\n        ? extractRules(validation)\n        : clone(validation);\n    return intents.reduce((validations, args) => {\n        let rule = args.shift();\n        const hints = {};\n        if (typeof rule === 'string') {\n            const [ruleName, parsedHints] = parseHints(rule);\n            if (has(rules, ruleName)) {\n                rule = rules[ruleName];\n                Object.assign(hints, parsedHints);\n            }\n        }\n        if (typeof rule === 'function') {\n            validations.push({\n                rule,\n                args,\n                timer: 0,\n                state: null,\n                queued: true,\n                deps: new Map(),\n                ...defaultHints,\n                ...fnHints(hints, rule),\n            });\n        }\n        return validations;\n    }, []);\n}\n/**\n * A string of validation rules written in FormKitRule notation.\n * @param validation - The string of rules\n * @internal\n */\nfunction extractRules(validation) {\n    return validation.split('|').reduce((rules, rule) => {\n        const parsedRule = parseRule(rule);\n        if (parsedRule) {\n            rules.push(parsedRule);\n        }\n        return rules;\n    }, []);\n}\n/**\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\n * @param rule - A string representing a validation rule.\n * @returns\n */\nfunction parseRule(rule) {\n    const trimmed = rule.trim();\n    if (trimmed) {\n        const matches = trimmed.match(ruleExtractor);\n        if (matches && typeof matches[1] === 'string') {\n            const ruleName = matches[1].trim();\n            const args = matches[2] && typeof matches[2] === 'string'\n                ? matches[2].split(',').map((s) => s.trim())\n                : [];\n            return [ruleName, ...args];\n        }\n    }\n    return false;\n}\n/**\n * Given a rule name, detect if there are any additional hints like !\n * @param ruleName - string representing a rule name\n * @returns\n */\nfunction parseHints(ruleName) {\n    const matches = ruleName.match(hintExtractor);\n    if (!matches) {\n        return [ruleName, { name: ruleName }];\n    }\n    const map = {\n        '*': { force: true },\n        '+': { skipEmpty: false },\n        '?': { blocking: false },\n    };\n    const [, hints, rule] = matches;\n    const hintGroups = hasDebounce.test(hints)\n        ? hints.match(debounceExtractor) || []\n        : [, hints];\n    return [\n        rule,\n        [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints, group) => {\n            if (!group)\n                return hints;\n            if (hasDebounce.test(group)) {\n                hints.debounce = parseInt(group.substr(1, group.length - 1));\n            }\n            else {\n                group\n                    .split('')\n                    .forEach((hint) => has(map, hint) && Object.assign(hints, map[hint]));\n            }\n            return hints;\n        }, { name: rule }),\n    ];\n}\n/**\n * Extracts hint properties from the validation rule function itself and applies\n * them if they are not already in the set of validation hints extracted from\n * strings.\n * @param existingHints - An existing set of hints already parsed\n * @param rule - The actual rule function, which can contain hint properties\n * @returns\n */\nfunction fnHints(existingHints, rule) {\n    if (!existingHints.name) {\n        existingHints.name = rule.ruleName || rule.name;\n    }\n    return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce((hints, hint) => {\n        if (has(rule, hint) && !has(hints, hint)) {\n            Object.assign(hints, {\n                [hint]: rule[hint],\n            });\n        }\n        return hints;\n    }, existingHints);\n}\n\nexport { createValidationPlugin };\n", "import { has } from '@formkit/utils';\n\n/**\n * Given a string, convert it to sentence case.\n * @param item - The string to sentence case\n * @returns\n * @public\n */\nfunction sentence(str) {\n    return str[0].toUpperCase() + str.substr(1);\n}\n/**\n * Creates an oxford-comma separated list of items.\n * @param args - items to list out\n * @param conjunction - in: x, y, and z \"and\" is the conjunction to use\n * @returns\n * @public\n */\nfunction list(items, conjunction = 'or') {\n    return items.reduce((oxford, item, index) => {\n        oxford += item;\n        if (index <= items.length - 2 && items.length > 2) {\n            oxford += ', ';\n        }\n        if (index === items.length - 2) {\n            oxford += `${items.length === 2 ? ' ' : ''}${conjunction} `;\n        }\n        return oxford;\n    }, '');\n}\n/**\n * Given a string or a date return a nice human-readable version.\n * @param date - A string or a date.\n * @public\n */\nfunction date(date) {\n    const dateTime = typeof date === 'string' ? new Date(Date.parse(date)) : date;\n    if (!(dateTime instanceof Date)) {\n        return '(unknown)';\n    }\n    return new Intl.DateTimeFormat(undefined, {\n        dateStyle: 'medium',\n    }).format(dateTime);\n}\n/**\n * Orders two variables smallest to largest.\n * @param first - first argument\n * @param second - Second argument\n * @returns\n * @public\n */\nfunction order(first, second) {\n    return Number(first) >= Number(second) ? [second, first] : [first, second];\n}\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$v = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\u0625\u0636\u0627\u0641\u0629',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0625\u0632\u0627\u0644\u0629',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0625\u0632\u0627\u0644\u0629 \u0627\u0644\u0643\u0644',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0639\u0630\u0631\u0627\u060C \u0644\u0645 \u064A\u062A\u0645 \u062A\u0639\u0628\u0626\u0629 \u062C\u0645\u064A\u0639 \u0627\u0644\u062D\u0642\u0648\u0644 \u0628\u0634\u0643\u0644 \u0635\u062D\u064A\u062D.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u0625\u0631\u0633\u0627\u0644',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0644\u0627 \u064A\u0648\u062C\u062F \u0645\u0644\u0641 \u0645\u062E\u062A\u0627\u0631',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$v = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u0627\u0644\u0631\u062C\u0627\u0621 \u0642\u0628\u0648\u0644 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u0639\u062F ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0633\u062A\u0642\u0628\u0644.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0623\u0628\u062C\u062F\u064A\u0629 \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0623\u0631\u0642\u0627\u0645 \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u062A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0645\u0633\u0627\u0641\u0627\u062A \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0642\u0628\u0644 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0627\u0636\u064A.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0627 \u0628\u064A\u0646 ${a} \u0648 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u063A\u064A\u0631 \u0645\u062A\u0637\u0627\u0628\u0642.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u0644\u064A\u0633 \u062A\u0627\u0631\u064A\u062E\u064B\u0627 \u0635\u0627\u0644\u062D\u064B\u0627 \u060C \u064A\u0631\u062C\u0649 \u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0627\u0644\u062A\u0646\u0633\u064A\u0642 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${date(args[0])} \u0648 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u0627\u0644\u0631\u062C\u0627\u0621 \u0623\u062F\u062E\u0627\u0644 \u0628\u0631\u064A\u062F \u0625\u0644\u064A\u0643\u062A\u0631\u0648\u0646\u064A \u0635\u0627\u0644\u062D.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `\u0644\u0627 \u064A\u0646\u062A\u0647\u064A ${sentence(name)} \u0628\u0640 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u062D\u0631\u0641\u064B\u0627 \u0648\u0627\u062D\u062F\u064B\u0627 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${max} \u062D\u0631\u0641\u064B\u0627.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0643\u0628\u0631 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${min} \u062D\u0631\u0641\u064B\u0627.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${min} \u0648 ${max} \u062D\u0631\u0641\u064B\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0643\u062B\u0631 \u0645\u0646 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0644\u0627 \u064A\u0633\u0645\u062D \u0628\u062A\u0646\u0633\u064A\u0642\u0627\u062A \u0627\u0644\u0645\u0644\u0641\u0627\u062A.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0646 \u0627\u0644\u0646\u0648\u0639: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0642\u0644 \u0645\u0646 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u0644\u064A\u0633 ${name} \u0645\u0633\u0645\u0648\u062D\u064B\u0627 \u0628\u0647.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u064A\u062C\u0628 \u0627\u0646 \u064A\u0643\u0648\u0646 \u0631\u0642\u0645\u0627\u064B`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u0645\u0637\u0644\u0648\u0628.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `\u0644\u0627 \u064A\u0628\u062F\u0623 ${sentence(name)} \u0628\u0640 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0627\u0644\u0631\u062C\u0627\u0621 \u062A\u0636\u0645\u064A\u0646 \u0639\u0646\u0648\u0627\u0646 \u0631\u0627\u0628\u0637 \u0635\u062D\u064A\u062D.`;\n        /* </i18n> */\n    },\n};\n\nvar ar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$v,\n    validation: validation$v\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$u = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: '\u0414\u043E\u0431\u0430\u0432\u0438',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u041F\u0440\u0435\u043C\u0430\u0445\u043D\u0438',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u041F\u0440\u0435\u043C\u0430\u0445\u043D\u0438 \u0432\u0441\u0438\u0447\u043A\u0438',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0418\u0437\u0432\u0438\u043D\u0435\u0442\u0435, \u043D\u0435 \u0432\u0441\u0438\u0447\u043A\u0438 \u043F\u043E\u043B\u0435\u0442\u0430 \u0441\u0430 \u043F\u043E\u043F\u044A\u043B\u043D\u0435\u043D\u0438 \u043F\u0440\u0430\u0432\u0438\u043B\u043D\u043E.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u0418\u0437\u043F\u0440\u0430\u0442\u0438',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u041D\u044F\u043C\u0430 \u0438\u0437\u0431\u0440\u0430\u043D \u0444\u0430\u0439\u043B',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$u = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u041C\u043E\u043B\u044F \u043F\u0440\u0438\u0435\u043C\u0435\u0442\u0435 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0435 \u0441\u043B\u0435\u0434 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u0432 \u0431\u044A\u0434\u0435\u0449\u0435\u0442\u043E.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u043C\u043E\u0436\u0435 \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 \u0441\u0430\u043C\u043E \u0431\u0443\u043A\u0432\u0438.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u043C\u043E\u0436\u0435 \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 \u0441\u0430\u043C\u043E \u0431\u0443\u043A\u0432\u0438 \u0438 \u0446\u0438\u0444\u0440\u0438.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u043C\u043E\u0436\u0435 \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 \u0441\u0430\u043C\u043E \u0431\u0443\u043A\u0432\u0438 \u0438 \u0438\u043D\u0442\u0435\u0440\u0432\u0430\u043B\u0438.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0435 \u043F\u0440\u0435\u0434\u0438 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u0432 \u043C\u0438\u043D\u0430\u043B\u043E\u0442\u043E.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u0422\u043E\u0432\u0430 \u043F\u043E\u043B\u0435 \u0435 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u0430\u043D\u043E \u043D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435 \u0434\u0430 \u0431\u044A\u0434\u0435 \u0438\u0437\u043F\u0440\u0430\u0442\u0435\u043D\u043E`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043C\u0435\u0436\u0434\u0443 ${a} \u0438 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u043D\u0435 \u0441\u044A\u0432\u043F\u0430\u0434\u0430.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u0435 \u043D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0434\u0430\u0442\u0430. \u041C\u043E\u043B\u044F, \u0438\u0437\u043F\u043E\u043B\u0437\u0432\u0430\u0439\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442\u0430 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u0422\u043E\u0432\u0430 \u043F\u043E\u043B\u0435 \u0435 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u0430\u043D\u043E \u043D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435 \u0434\u0430 \u0431\u044A\u0434\u0435 \u0438\u0437\u043F\u0440\u0430\u0442\u0435\u043D\u043E';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043C\u0435\u0436\u0434\u0443 ${date(args[0])} \u0438 ${date(args[1])}.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u041C\u043E\u043B\u044F, \u0432\u044A\u0432\u0435\u0434\u0435\u0442\u0435 \u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u043D\u0435 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u043D\u0430 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0435 \u043D\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0438\u043C\u0430 \u043F\u043E\u043D\u0435 \u0435\u0434\u0438\u043D \u0441\u0438\u043C\u0432\u043E\u043B.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043F\u043E-\u043C\u0430\u043B\u043A\u043E \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E \u043D\u0430 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043F\u043E-\u0433\u043E\u043B\u044F\u043C\u043E \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E \u043D\u0430 ${min} \u0441\u0438\u043C\u0432\u043E\u043B\u0430.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043C\u0435\u0436\u0434\u0443 ${min} \u0438 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0435 \u043D\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435 \u0434\u0430 \u0438\u043C\u0430 \u043F\u043E\u0432\u0435\u0447\u0435 \u043E\u0442 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043F\u043E-\u043C\u0430\u043B\u043A\u043E \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E \u043D\u0430 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u041D\u0435 \u0441\u0430 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438 \u043D\u0438\u043A\u0430\u043A\u0432\u0438 \u0444\u0430\u0439\u043B\u043E\u0432\u0438 \u0444\u043E\u0440\u043C\u0430\u0442\u0438.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043E\u0442 \u0442\u0438\u043F: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435 \u0434\u0430 \u0438\u043C\u0430 \u043F\u043E-\u043C\u0430\u043B\u043A\u043E \u043E\u0442 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043F\u043E\u043D\u0435 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u0435 \u043D\u0435\u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u0447\u0438\u0441\u043B\u043E.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u0435 \u0437\u0430\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u043D\u0435 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u041C\u043E\u043B\u044F, \u0432\u044A\u0432\u0435\u0434\u0435\u0442\u0435 \u0432\u0430\u043B\u0438\u0434\u0435\u043D URL \u0430\u0434\u0440\u0435\u0441.`;\n        /* </i18n> */\n    },\n};\n\nvar bg = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$u,\n    validation: validation$u\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$t = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'P\u0159idat',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Odebrat',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Odebrat v\u0161e',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pardon, ale ne v\u0161echna pole jsou vypln\u011Bna spr\u00E1vn\u011B.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Odeslat',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u017D\u00E1dn\u00FD soubor nebyl vybr\u00E1n',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$t = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Pros\u00EDm, za\u0161krtn\u011Bte ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED b\u00FDt po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt v budoucnosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\u00EDsmena.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\u00EDsmena a \u010D\u00EDsla.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED b\u00FDt p\u0159ed ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt v minulosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Toto pole bylo \u0161patn\u011B nakonfigurov\u00E1no a nem\u016F\u017Ee b\u00FDt odesl\u00E1no.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt mezi ${a} a ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nejsou shodn\u00E1.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nen\u00ED platn\u00E9 datum, pros\u00EDm, pou\u017Eijte form\u00E1t ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Toto pole bylo \u0161patn\u011B nakonfigurov\u00E1no a nem\u016F\u017Ee b\u00FDt odesl\u00E1no.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt mezi ${date(args[0])} a ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Pros\u00EDm, zadejte platnou e-mailovou adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nekon\u010D\u00ED na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nen\u00ED povolen\u00E1 hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mus\u00ED m\u00EDt nejm\u00E9n\u011B jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} m\u016F\u017Ee m\u00EDt maxim\u00E1ln\u011B ${max} znak\u016F.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED obsahovat minim\u00E1ln\u011B ${min} znak\u016F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt dlouh\u00E9 ${min} a\u017E ${max} znak\u016F.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nen\u00ED povolen\u00E1 hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nelze pou\u017E\u00EDt v\u00EDce ne\u017E ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED m\u00EDt men\u0161\u00ED nebo rovno ne\u017E ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nejsou nakonfigurov\u00E1ny povolen\u00E9 typy soubor\u016F.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt typu: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Nelze m\u00EDt m\u00E9n\u011B ne\u017E ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt minim\u00E1ln\u011B ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nen\u00ED dovolen\u00E1 hodnota pro ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt \u010D\u00EDslo.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je povinn\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} neza\u010D\u00EDn\u00E1 na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Zadejte, pros\u00EDm, platnou URL adresu.`;\n        /* </i18n> */\n    },\n};\n\nvar cs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$t,\n    validation: validation$t\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$s = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Tilf\u00F8j',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Fjern',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Fjern alle',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Alle felter er ikke korrekt udfyldt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Send',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ingen filer valgt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$s = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepter venligst ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re senere end ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re i fremtiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og tal.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og mellemrum.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re f\u00F8r ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re f\u00F8r i dag.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} skal v\u00E6re mellem ${a} og ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} matcher ikke.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} er ikke gyldig, brug venligst formatet ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} skal v\u00E6re mellem ${date(args[0])} og ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Indtast venligst en gyldig email-adresse.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} slutter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} er ikke en gyldig v\u00E6rdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 mindst \u00E9t tegn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 h\u00F8jst ${max} tegn.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 mindst ${min} tegn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re p\u00E5 mindst ${min} og h\u00F8jst ${max} tegn.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} er ikke en gyldig v\u00E6rdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Kan ikke have flere end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re mindre eller lig med ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Ingen filformater tilladt.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re af filtypen: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Kan ikke have mindre end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re mindst ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D er ikke en tilladt ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} skal v\u00E6re et tal.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} er p\u00E5kr\u00E6vet.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} starter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Indtast venligst en gyldig URL.`;\n        /* </i18n> */\n    },\n};\n\nvar da = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$s,\n    validation: validation$s\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$r = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Hinzuf\u00FCgen',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Entfernen',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Alles entfernen',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Entschuldigung, nicht alle Felder wurden korrekt ausgef\u00FCllt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Senden',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Keine Datei ausgew\u00E4hlt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$r = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Bitte ${name} akzeptieren.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} muss nach dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Zukunft liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben und Zahlen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} d\u00FCrfen nur Buchstaben und Leerzeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} muss vor dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Vergangenheit liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dieses Feld wurde falsch konfiguriert und kann nicht \u00FCbermittelt werden.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} muss zwischen ${args[0]} und ${args[1]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} stimmt nicht \u00FCberein.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ist kein g\u00FCltiges Datum im Format ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dieses Feld wurde falsch konfiguriert und kann nicht \u00FCbermittelt werden.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} muss zwischen ${date(args[0])} und ${date(args[1])} liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'E-Mail Adresse ist ung\u00FCltig.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} endet nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} enth\u00E4lt einen ung\u00FCltigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} muss mindestens ein Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} darf maximal ${max} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} muss mindestens ${min} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} muss zwischen ${min} und ${max} Zeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} enth\u00E4lt einen ung\u00FCltigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Darf maximal ${args[0]} ${name} haben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} darf maximal ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Keine Dateiformate konfiguriert.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} muss vom Typ ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mindestens ${args[0]} ${name} erforderlich.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} muss mindestens ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ist kein g\u00FCltiger Wert f\u00FCr ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} muss eine Zahl sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} ist erforderlich.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} beginnt nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `URL ist ung\u00FCltig.`;\n        /* </i18n> */\n    },\n};\n\nvar de = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$r,\n    validation: validation$r\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$q = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: 'Add',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remove',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Remove all',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, not all fields are filled out correctly.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Submit',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'No file chosen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$q = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Please accept the ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} must be after ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the future.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} can only contain alphabetical characters.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} can only contain letters and numbers.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} can only contain letters and spaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} must be before ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the past.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `This field was configured incorrectly and can\u2019t be submitted.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} must be between ${a} and ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} does not match.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is not a valid date, please use the format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'This field was configured incorrectly and can\u2019t be submitted';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} must be between ${date(args[0])} and ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Please enter a valid email address.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn\u2019t end with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} must be at least one character.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} must be less than or equal to ${max} characters.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} must be greater than or equal to ${min} characters.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} must be between ${min} and ${max} characters.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} must be less than or equal to ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No file formats allowed.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} must be of the type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} must be at least ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D is not an allowed ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} must be a number.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is required.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn\u2019t start with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Please include a valid url.`;\n        /* </i18n> */\n    },\n};\n\nvar en = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$q,\n    validation: validation$q\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$p = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'A\u00F1adir',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Quitar',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Quitar todos',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Disc\u00FAlpe, los campos no fueron completados correctamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Archivo no seleccionado',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$p = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Acepte el ${name} por favor.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha futura.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} debe contener solo caract\u00E9res alfab\u00E9ticos.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} debe ser alfanum\u00E9rico.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} espacios alfa solo pueden contener letras y espacios.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha pasada.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `El campo no fue completado correctamente y no puede ser enviado.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} debe estar entre ${a} y ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} no coincide.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} no es una fecha v\u00E1lida, por favor utilice el formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'El campo no fue completado correctamente y no puede ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} debe estar entre ${date(args[0])} y ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Ingrese una direcci\u00F3n de correo electr\u00F3nico v\u00E1lida por favor.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} no termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} debe tener al menos una letra.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como m\u00E1ximo ${max} caract\u00E9res.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como m\u00EDnimo ${min} caract\u00E9res.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} debe tener entre ${min} y ${max} caract\u00E9res.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser menor o igual a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No existen formatos de archivos permitidos.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} debe ser del tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser de al menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D no es un valor permitido de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} debe ser un n\u00FAmero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} es requerido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} debe comenzar con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Proporcione una URL v\u00E1lida por favor.`;\n        /* </i18n> */\n    },\n};\n\nvar es = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$p,\n    validation: validation$p\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$o = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\u0627\u0641\u0632\u0648\u062F\u0646',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u062D\u0630\u0641',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0647\u0645\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0647\u0645\u0647 \u0641\u06CC\u0644\u062F\u0647\u0627 \u0628\u0647\u200C\u062F\u0631\u0633\u062A\u06CC \u067E\u0631 \u0646\u0634\u062F\u0647\u200C\u0627\u0646\u062F',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u062B\u0628\u062A',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0647\u06CC\u0686 \u0641\u0627\u06CC\u0644\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0646\u0634\u062F\u0647 \u0627\u0633\u062A',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$o = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u0644\u0637\u0641\u0627\u064B ${name} \u0631\u0627 \u0628\u067E\u0630\u06CC\u0631\u06CC\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0639\u062F \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date(args[0])} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u0622\u06CC\u0646\u062F\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0627\u0644\u0641\u0628\u0627 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0627\u0639\u062F\u0627\u062F \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0641\u0627\u0635\u0644\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0642\u0628\u0644 \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date(args[0])} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u06AF\u0630\u0634\u062A\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${args[0]} \u0648 ${args[1]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u0645\u0637\u0627\u0628\u0642\u062A \u0646\u062F\u0627\u0631\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u062A\u0627\u0631\u06CC\u062E \u0645\u0639\u062A\u0628\u0631\u06CC \u0646\u06CC\u0633\u062A\u060C \u0644\u0637\u0641\u0627\u064B \u0627\u0632 \u0642\u0627\u0644\u0628 ${args[0]} \u0627\u0633\u062A\u0641\u0627\u062F\u0647 \u06A9\u0646\u06CC\u062F\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${date(args[0])} \u0648 ${date(args[1])} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u0644\u0637\u0641\u0627 \u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644 \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0647 ${list(args)} \u062E\u062A\u0645 \u0634\u0648\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 \u06CC\u06A9 \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${max} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0632\u0631\u06AF\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${min} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${min} \u0648 ${max} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0628\u06CC\u0634 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${args[0]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0641\u0631\u0645\u062A \u0641\u0627\u06CC\u0644 \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0627\u0632 \u0627\u06CC\u0646 \u0646\u0648\u0639 \u0628\u0627\u0634\u062F: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u06A9\u0645\u062A\u0631 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 ${args[0]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" \u06CC\u06A9 ${name} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0639\u062F\u062F \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `\u067E\u0631 \u06A9\u0631\u062F\u0646 ${sentence(name)} \u0627\u062C\u0628\u0627\u0631\u06CC \u0627\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0627 ${list(args)} \u0634\u0631\u0648\u0639 \u0634\u0648\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0644\u0637\u0641\u0627\u064B \u0622\u062F\u0631\u0633 \u0627\u06CC\u0646\u062A\u0631\u0646\u062A\u06CC \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.`;\n        /* </i18n> */\n    },\n};\n\nvar fa = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$o,\n    validation: validation$o\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$n = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Lis\u00E4\u00E4',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Poista',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Poista kaikki',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Kaikkia kentti\u00E4 ei ole t\u00E4ytetty oikein.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Tallenna',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ei valittuja tiedostoja',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$n = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Ole hyv\u00E4 ja hyv\u00E4ksy ${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ${date(args[0])} j\u00E4lkeen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava tulevaisuudessa.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} saa sis\u00E4lt\u00E4\u00E4 vain kirjaimia.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} saa sis\u00E4lt\u00E4\u00E4 vain kirjaimia ja numeroita.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} voivat sis\u00E4lt\u00E4\u00E4 vain kirjaimia ja v\u00E4lily\u00F6ntej\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ennen: ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava menneisyydess\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `T\u00E4m\u00E4 kentt\u00E4 on t\u00E4ytetty virheellisesti joten sit\u00E4 ei voitu l\u00E4hett\u00E4\u00E4.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} on oltava v\u00E4lill\u00E4 ${a} - ${b} `;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ei t\u00E4sm\u00E4\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ei ole validi p\u00E4iv\u00E4m\u00E4\u00E4r\u00E4, ole hyv\u00E4 ja sy\u00F6t\u00E4 muodossa: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'T\u00E4m\u00E4 kentt\u00E4 on t\u00E4ytetty virheellisesti joten sit\u00E4 ei voitu l\u00E4hett\u00E4\u00E4.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} on oltava v\u00E4lill\u00E4 ${date(args[0])} - ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Sy\u00F6t\u00E4 validi s\u00E4hk\u00F6postiosoite.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tulee p\u00E4\u00E4tty\u00E4 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ei ole sallittu vaihtoehto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n yksi merkki.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} on oltava ${max} tai alle merkki\u00E4.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n ${min} merkki\u00E4.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n ${min}, enint\u00E4\u00E4n ${max} merkki\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ei ole sallittu arvo.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Valitse enint\u00E4\u00E4n ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} on oltava ${args[0]} tai alle.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Tiedostoja ei sallita.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]}-tiedostotyyppi\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Valitse v\u00E4hint\u00E4\u00E4n ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]} tai suurempi.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ei ole sallittu ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `Kent\u00E4n ${sentence(name)} tulee olla numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} vaaditaan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} on alettava ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Sy\u00F6t\u00E4 validi url-osoite.`;\n        /* </i18n> */\n    },\n};\n\nvar fi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$n,\n    validation: validation$n\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$m = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Ajouter',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Supprimer',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Enlever tout',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'D\u00E9sol\u00E9, tous les champs ne sont pas remplis correctement.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Valider',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Aucun fichier choisi',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$m = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Veuillez accepter le ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre post\u00E9rieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre dans le futur.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} ne peut contenir que des caract\u00E8res alphab\u00E9tiques.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} ne peut contenir que des lettres et des chiffres.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} ne peuvent contenir que des lettres et des espaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre ant\u00E9rieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre dans le pass\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Ce champ a \u00E9t\u00E9 configur\u00E9 de mani\u00E8re incorrecte et ne peut pas \u00EAtre soumis.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${a} et ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne correspond pas.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} n'est pas une date valide, veuillez utiliser le format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ce champ a \u00E9t\u00E9 configur\u00E9 de mani\u00E8re incorrecte et ne peut pas \u00EAtre soumis.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${date(args[0])} et ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Veuillez saisir une adresse email valide.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne se termine pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} n'est pas une valeur autoris\u00E9e.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} doit comporter au moins un caract\u00E8re.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre inf\u00E9rieur ou \u00E9gal \u00E0 ${max} caract\u00E8res.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre sup\u00E9rieur ou \u00E9gal \u00E0 ${min} caract\u00E8res.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${min} et ${max} caract\u00E8res.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} n'est pas une valeur autoris\u00E9e.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne peut pas avoir plus de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre inf\u00E9rieur ou \u00E9gal \u00E0 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Aucun format de fichier n\u2019est autoris\u00E9';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre du type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Ne peut pas avoir moins de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre au moins de ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D n'est pas un ${name} autoris\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} doit \u00EAtre un nombre.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} est requis.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne commence pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Veuillez saisir une url valide.`;\n        /* </i18n> */\n    },\n};\n\nvar fr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$m,\n    validation: validation$m\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$l = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: 'Foeg ta',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ferwider',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Ferwider alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, net alle fjilden binne korrekt ynfolle.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Ferstjoere',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Gjin best\u00E2n keazen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$l = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Akseptearje de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moat nei ${date(args[0])} w\u00EAze.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn de takomst lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mei allinne alfabetyske tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mei allinne letters en sifers befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mei allinne letters en spaasjes befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moat foar ${date(args[0])} falle.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn it ferline w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moat tusken ${a} en ${b} lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt net oerien.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is gjin jildige datum, br\u00FBk de notaasje ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moat tusken ${date(args[0])} en ${date(args[1])} lizze`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Folje in jildich e-mailadres yn.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} einiget net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moat minimaal ien teken w\u00EAze.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moat lytser w\u00EAze as of gelyk w\u00EAze oan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moat grutter w\u00EAze as of gelyk w\u00EAze oan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moat tusken de ${min} en ${max} tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mei net mear as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moat lytser w\u00EAze as of gelyk w\u00EAze oan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Gjin best\u00E2nsnotaasjes tastien.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moat fan it type: ${args[0]} w\u00EAze`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mei net minder as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moat minimaal ${args[0]} w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is gjin tastiene ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moat in getal w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is ferplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begjint net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Doch der in jildige url by.`;\n        /* </i18n> */\n    },\n};\n\nvar fy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$l,\n    validation: validation$l\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$k = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\u05D4\u05D5\u05E1\u05E3',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u05DE\u05D7\u05E7',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u05E9\u05D9\u05DD \u05DC\u05D1, \u05DC\u05D0 \u05DB\u05DC \u05D4\u05E9\u05D3\u05D5\u05EA \u05DE\u05DC\u05D0\u05D9\u05DD \u05DB\u05E8\u05D0\u05D5\u05D9.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u05E9\u05DC\u05D7',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$k = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u05D0\u05E0\u05D0 \u05D0\u05E9\u05E8 \u05D0\u05EA ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D0\u05D7\u05E8\u05D9 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05EA\u05D9\u05D3.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05DB\u05D9\u05DC \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D0\u05DC\u05E4\u05D1\u05EA.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05DE\u05E1\u05E4\u05E8\u05D9\u05DD \u05D5\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D5\u05E8\u05D5\u05D5\u05D7\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05E0\u05D9 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05D1\u05E8`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${args[0]} \u05D5-${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05EA\u05D0\u05E8\u05D9\u05DA \u05EA\u05E7\u05D9\u05DF, \u05D0\u05E0\u05D0 \u05D4\u05E9\u05EA\u05DE\u05E9 \u05D1\u05E4\u05D5\u05E8\u05DE\u05D8 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${date(args[0])} \u05D5- ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC \u05EA\u05E7\u05D9\u05DF.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05DE\u05D5\u05E8\u05E9\u05D4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA \u05EA\u05D5 \u05D0\u05D7\u05D3.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${max} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D9\u05D5\u05EA \u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${min} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${min} \u05D5- ${max} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05EA\u05E7\u05D9\u05DF.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05D9\u05D5\u05EA\u05E8 \u05DE- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u05E4\u05D5\u05E8\u05DE\u05D8 \u05D4\u05E7\u05D5\u05D1\u05E5 \u05DC\u05D0 \u05DE\u05D5\u05E8\u05E9\u05D4.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05D5\u05D2: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05E4\u05D7\u05D5\u05EA \u05DE- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD \u05DC- ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05E4\u05E8.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u05D4\u05D9\u05E0\u05D5 \u05D7\u05D5\u05D1\u05D4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D7\u05D9\u05DC \u05D1- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05E7\u05D9\u05E9\u05D5\u05E8 \u05EA\u05E7\u05D9\u05DF.`;\n        /* </i18n> */\n    },\n};\n\nvar he = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$k,\n    validation: validation$k\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$j = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Dodaj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ukloni',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pojedina polja nisu ispravno ispunjena.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Predaj',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$j = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Potrebno je potvrditi ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti u periodu poslije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u budu\u0107nosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mora sadr\u017Eavati samo slova.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mora sadr\u017Eavati slova i brojeve.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mogu sadr\u017Eavati samo slova i razmake..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti prije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u pro\u0161losti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Format sadr\u017Eaja nije ispravan i ne mo\u017Ee biti predan.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mora biti izme\u0111u ${args[0]} i ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne odgovara zadanoj vrijednosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nije ispravan format datuma. Molimo koristite sljede\u0107i format: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ovo polje nije ispravno postavljeno i ne mo\u017Ee biti predano.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mora biti vrijednost izme\u0111u ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Molimo upi\u0161ite ispravnu email adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne zavr\u0161ava s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nije dopu\u0161tena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mora sadr\u017Eavati barem jedan znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mora imati ${max} ili manje znakova.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mora imati barem ${min} znakova.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `Broj znakova za polje ${sentence(name)} mora biti izme\u0111u ${min} i ${max}.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nije dozvoljena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne smije imati vi\u0161e od ${args[0]} ${name} polja.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mora imati vrijednost manju ili jednaku ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format datoteke nije dozvoljen.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `Format datoteke na polju ${sentence(name)} mora odgovarati: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Broj upisanih vrijednosti na polju ${name} mora biti barem ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mora biti barem ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nije dozvoljena vrijednost na polju ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mora biti broj.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je obavezno.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne po\u010Dinje s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Molimo unesite ispravnu poveznicu.`;\n        /* </i18n> */\n    },\n};\n\nvar hr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$j,\n    validation: validation$j\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$i = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: 'Hozz\u00E1ad\u00E1s',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Elt\u00E1vol\u00EDt\u00E1s',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u00D6sszes elt\u00E1vol\u00EDt\u00E1sa',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sajn\u00E1ljuk, nem minden mez\u0151 lett helyesen kit\u00F6ltve.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Bek\u00FCld\u00E9s',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nincs f\u00E1jl kiv\u00E1lasztva',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$i = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Fogadja el a ${name} mez\u0151t.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mez\u0151nek ${date(args[0])} ut\u00E1n kell lennie.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mez\u0151nek a j\u00F6v\u0151ben kell lennie.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} csak alfanumerikus karaktereket tartalmazhat.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} csak bet\u0171ket \u00E9s sz\u00E1mokat tartalmazhat.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} csak bet\u0171ket \u00E9s sz\u00F3k\u00F6z\u00F6ket tartalmazhat.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mez\u0151nek ${date(args[0])} el\u0151tt kell lennie.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mez\u0151nek a m\u00FAltban kell lennie.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Ez a mez\u0151 hib\u00E1san lett konfigur\u00E1lva, \u00EDgy nem lehet bek\u00FCldeni.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `A ${sentence(name)} mez\u0151nek ${a} \u00E9s ${b} k\u00F6z\u00F6tt kell lennie.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nem egyezik.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nem \u00E9rv\u00E9nyes d\u00E1tum, ${args[0]} form\u00E1tumot haszn\u00E1lj`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ez a mez\u0151 hib\u00E1san lett konfigur\u00E1lva, \u00EDgy nem lehet bek\u00FCldeni.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mez\u0151nek ${date(args[0])} \u00E9s ${args[1]} k\u00F6z\u00F6tt kell lennie`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'K\u00E9rj\u00FCk, \u00E9rv\u00E9nyek email c\u00EDmet adjon meg.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} mez\u0151 nem a kijel\u00F6lt (${list(args)}) m\u00F3don \u00E9r v\u00E9get.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nem enged\u00E9lyezett \u00E9rt\u00E9k.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mez\u0151nek legal\u00E1bb egy karakteresnek kell lennie.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mez\u0151nek maximum ${max} karakteresnek kell lennie.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mez\u0151nek minimum ${min} karakteresnek kell lennie.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} mez\u0151nek ${min} \u00E9s ${max} karakter k\u00F6z\u00F6tt kell lennie.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nem enged\u00E9lyezett \u00E9rt\u00E9k.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nem lehet t\u00F6bb mint ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} nem lehet nagyobb, mint ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nincsenek t\u00E1mogatott f\u00E1jlform\u00E1tumok.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)}-nak/nek a k\u00F6vetkez\u0151nek kell lennie: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Nem lehet kevesebb, mint ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)}-nak/nek minimum ${args[0]}-nak/nek kell lennie.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" nem enged\u00E9lyezett ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mez\u0151nek sz\u00E1mnak kell lennie.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} mez\u0151 k\u00F6telez\u0151.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nem a k\u00F6vetkez\u0151vel kezd\u0151dik: ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `K\u00E9rj\u00FCk, \u00E9rv\u00E9nyes URL-t adjon meg.`;\n        /* </i18n> */\n    },\n};\n\nvar hu = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$i,\n    validation: validation$i\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$h = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Tambah',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Hapus',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hapus semua',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maaf, tidak semua bidang formulir terisi dengan benar',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Kirim',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Tidak ada file yang dipilih',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$h = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Tolong terima kolom ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus lebih dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu di masa depan.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf alfabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf dan angka.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} hanya boleh berisi huruf dan spasi..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus kurang dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu yang sudah lampau.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} harus bernilai diantara ${a} dan ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nilainya tidak cocok.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} waktu tidak cocok, mohon gunakan format waktu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} harus diantara waktu ${date(args[0])} dan waktu ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Tolong tulis alamat email yang benar.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nilainya tidak berakhiran dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} adalah nilai yang tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} nilainya setidaknya berisi satu karakter.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus kurang dari atau sama dengan ${max} karakter.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus lebih dari atau sama dengan ${min} karakter.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} jumlah karakternya hanya bisa antara ${min} dan ${max} karakter.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nilainya tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Tidak bisa memiliki lebih dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} harus lebih kecil atau sama dengan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format file tidak diizinkan';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} hanya bisa bertipe: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Tidak boleh kurang dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} setidaknya harus berisi ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D adalah nilai yang tidak diperbolehkan untuk ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} harus berupa angka.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} harus diisi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tidak dimulai dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Mohon tuliskan url yang benar.`;\n        /* </i18n> */\n    },\n};\n\nvar id = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$h,\n    validation: validation$h\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$g = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Inserisci',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Rimuovi',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Rimuovi tutti',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Ci dispiace, non tutti i campi sono compilati correttamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Invia',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nessun file selezionato',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$g = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Si prega di accettare ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere successiva ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `la data ${sentence(name)} deve essere nel futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo caratteri alfanumerici.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo lettere e numeri.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo lettere e spazi.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere antecedente ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve essere nel passato.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Questo campo \u00E8 stato configurato male e non pu\u00F2 essere inviato.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve essere tra ${a} e ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} non corrisponde.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} non \u00E8 una data valida, per favore usa il formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Questo campo \u00E8 stato configurato in modo errato e non pu\u00F2 essere inviato.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve essere tra ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Per favore inserire un indirizzo email valido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} non \u00E8 un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve contenere almeno un carattere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} deve essere minore o uguale a ${max} caratteri.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve essere maggiore o uguale a ${min} caratteri.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve essere tra ${min} e ${max} caratteri.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} non \u00E8 un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Non pu\u00F2 avere pi\u00F9 di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere minore o uguale a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Formato file non consentito.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve essere di tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Non pu\u00F2 avere meno di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere almeno ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" non \u00E8 un ${name} consentito.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve essere un numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u00E8 richiesto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non inizia con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Per favore utilizare un url valido.`;\n        /* </i18n> */\n    },\n};\n\nvar it = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$g,\n    validation: validation$g\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$f = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\u8FFD\u52A0',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u524A\u9664',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u5168\u3066\u524A\u9664',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u9805\u76EE\u304C\u6B63\u3057\u304F\u5165\u529B\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u9001\u4FE1',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u30D5\u30A1\u30A4\u30EB\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$f = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `${name}\u306E\u540C\u610F\u304C\u5FC5\u8981\u3067\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)}\u306F${date(args[0])}\u3088\u308A\u5F8C\u306E\u65E5\u4ED8\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u306F\u5C06\u6765\u306E\u65E5\u4ED8\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)}\u306B\u306F\u82F1\u5B57\u306E\u307F\u3092\u542B\u3081\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)}\u306B\u306F\u3001\u6587\u5B57\u3068\u6570\u5B57\u306E\u307F\u3092\u542B\u3081\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)}\u306B\u306F\u3001\u6587\u5B57\u3068\u30B9\u30DA\u30FC\u30B9\u306E\u307F\u3092\u542B\u3081\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)}\u306F${date(args[0])}\u3088\u308A\u524D\u306E\u65E5\u4ED8\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u306F\u904E\u53BB\u306E\u65E5\u4ED8\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u3053\u306E\u30D5\u30A3\u30FC\u30EB\u30C9\u306F\u6B63\u3057\u304F\u69CB\u6210\u3055\u308C\u3066\u3044\u306A\u3044\u305F\u3081\u3001\u9001\u4FE1\u3067\u304D\u307E\u305B\u3093\u3002`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)}\u306F${a}\u3068${b}\u306E\u9593\u306B\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)}\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)}\u306F\u6709\u52B9\u306A\u65E5\u4ED8\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002${args[0]}\u306E\u5F62\u5F0F\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u3053\u306E\u30D5\u30A3\u30FC\u30EB\u30C9\u306F\u6B63\u3057\u304F\u69CB\u6210\u3055\u308C\u3066\u304A\u3089\u305A\u3001\u9001\u4FE1\u3067\u304D\u307E\u305B\u3093\u3002';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}\u306F${date(args[0])}\u3068${date(args[1])}\u306E\u9593\u306B\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u6709\u52B9\u306A\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u306F${list(args)}\u3067\u7D42\u308F\u3063\u3066\u3044\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)}\u306F\u8A31\u53EF\u3055\u308C\u305F\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)}\u306F\u5C11\u306A\u304F\u3068\u30821\u6587\u5B57\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)}\u306F${max}\u6587\u5B57\u4EE5\u4E0B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)}\u306F${min}\u6587\u5B57\u4EE5\u4E0A\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}\u306F${min}\u304B\u3089${max}\u6587\u5B57\u306E\u9593\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)}\u306F\u8A31\u53EF\u3055\u308C\u305F\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}\u306F${args[0]}\u3092\u8D85\u3048\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)}\u306F${args[0]}\u4EE5\u4E0B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u30D5\u30A1\u30A4\u30EB\u5F62\u5F0F\u306F\u8A31\u53EF\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)}\u306F${args[0]}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}\u306F${args[0]}\u672A\u6E80\u306B\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)}\u306F\u5C11\u306A\u304F\u3068\u3082${args[0]}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D\u306F\u8A31\u53EF\u3055\u308C\u305F${name}\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)}\u306F\u6570\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)}\u306F\u5FC5\u9808\u3067\u3059\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u306F${list(args)}\u3067\u59CB\u307E\u3063\u3066\u3044\u307E\u305B\u3093\u3002`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u6709\u52B9\u306AURL\u3092\u542B\u3081\u3066\u304F\u3060\u3055\u3044\u3002`;\n        /* </i18n> */\n    },\n};\n\nvar ja = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$f,\n    validation: validation$f\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$e = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: '\u049B\u043E\u0441\u0443',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0416\u043E\u044E',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0411\u0430\u0440\u043B\u044B\u0493\u044B\u043D \u0436\u043E\u044E',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u041A\u0435\u0448\u0456\u0440\u0456\u04A3\u0456\u0437, \u0431\u0430\u0440\u043B\u044B\u049B \u04E9\u0440\u0456\u0441\u0442\u0435\u0440 \u0434\u04B1\u0440\u044B\u0441 \u0442\u043E\u043B\u0442\u044B\u0440\u044B\u043B\u043C\u0430\u0493\u0430\u043D.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u0416\u0456\u0431\u0435\u0440\u0443',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0415\u0448\u0431\u0456\u0440 \u0444\u0430\u0439\u043B \u0442\u0430\u04A3\u0434\u0430\u043B\u043C\u0430\u0434\u044B',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$e = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u049B\u0430\u0431\u044B\u043B\u0434\u0430\u04A3\u044B\u0437 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u043A\u0435\u0439\u0456\u043D \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E\u043B\u0430\u0448\u0430\u049B\u0442\u0430 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u0442\u0435\u043A \u0430\u043B\u0444\u0430\u0432\u0438\u0442\u0442\u0456\u043A \u0442\u0430\u04A3\u0431\u0430\u043B\u0430\u0440\u0434\u044B \u049B\u0430\u043C\u0442\u0443\u044B \u043C\u04AF\u043C\u043A\u0456\u043D.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u0442\u0435\u043A \u04D9\u0440\u0456\u043F\u0442\u0435\u0440 \u043C\u0435\u043D \u0441\u0430\u043D\u0434\u0430\u0440\u0434\u0430\u043D \u0442\u04B1\u0440\u0443\u044B \u043C\u04AF\u043C\u043A\u0456\u043D.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u0442\u0435\u043A \u04D9\u0440\u0456\u043F\u0442\u0435\u0440 \u043C\u0435\u043D \u0431\u043E\u0441 \u043E\u0440\u044B\u043D\u0434\u0430\u0440 \u0431\u043E\u043B\u0443\u044B \u043C\u04AF\u043C\u043A\u0456\u043D.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0431\u04B1\u0440\u044B\u043D \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u04E9\u0442\u043A\u0435\u043D\u0434\u0435 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u0411\u04B1\u043B \u04E9\u0440\u0456\u0441 \u049B\u0430\u0442\u0435 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F\u043B\u0430\u043D\u0493\u0430\u043D \u0436\u04D9\u043D\u0435 \u043E\u043D\u044B \u0436\u0456\u0431\u0435\u0440\u0443 \u043C\u04AF\u043C\u043A\u0456\u043D \u0435\u043C\u0435\u0441.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u0430\u0440\u0430\u0441\u044B\u043D\u0434\u0430 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${a} \u0436\u04D9\u043D\u0435 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u0441\u04D9\u0439\u043A\u0435\u0441 \u043A\u0435\u043B\u043C\u0435\u0439\u0434\u0456.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u0436\u0430\u0440\u0430\u043C\u0434\u044B \u043A\u04AF\u043D \u0435\u043C\u0435\u0441, \u043F\u0456\u0448\u0456\u043C\u0434\u0456 \u043F\u0430\u0439\u0434\u0430\u043B\u0430\u043D\u044B\u04A3\u044B\u0437 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u0411\u04B1\u043B \u04E9\u0440\u0456\u0441 \u049B\u0430\u0442\u0435 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F\u043B\u0430\u043D\u0493\u0430\u043D \u0436\u04D9\u043D\u0435 \u043E\u043D\u044B \u0436\u0456\u0431\u0435\u0440\u0443 \u043C\u04AF\u043C\u043A\u0456\u043D \u0435\u043C\u0435\u0441';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u0430\u0440\u0430\u0441\u044B\u043D\u0434\u0430 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${date(args[0])} \u0436\u04D9\u043D\u0435 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u04E8\u0442\u0456\u043D\u0435\u043C\u0456\u0437 \u049B\u043E\u043B\u0434\u0430\u043D\u044B\u0441\u0442\u0430\u0493\u044B \u044D\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u0434\u044B \u043F\u043E\u0448\u0442\u0430 \u0430\u0434\u0440\u0435\u0441\u0456\u043D \u0435\u043D\u0433\u0456\u0437\u0456\u04A3\u0456\u0437.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} -\u043C\u0435\u043D \u0431\u0456\u0442\u043F\u0435\u0439\u0434\u0456 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0440\u04B1\u049B\u0441\u0430\u0442 \u0435\u0442\u0456\u043B\u0433\u0435\u043D \u043C\u04D9\u043D \u0435\u043C\u0435\u0441.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u043A\u0435\u043C \u0434\u0435\u0433\u0435\u043D\u0434\u0435 \u0431\u0456\u0440 \u0442\u0430\u04A3\u0431\u0430 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u043A\u0435\u043C \u043D\u0435\u043C\u0435\u0441\u0435 \u0442\u0435\u04A3 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${max} \u043A\u0435\u0439\u0456\u043F\u043A\u0435\u0440\u043B\u0435\u0440.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u0430\u0440\u0442\u044B\u049B \u043D\u0435\u043C\u0435\u0441\u0435 \u0442\u0435\u04A3 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${min} \u043A\u0435\u0439\u0456\u043F\u043A\u0435\u0440\u043B\u0435\u0440.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u0430\u0440\u0430\u0441\u044B\u043D\u0434\u0430 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${min} \u0436\u04D9\u043D\u0435 ${max} \u043A\u0435\u0439\u0456\u043F\u043A\u0435\u0440\u043B\u0435\u0440.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0440\u04B1\u049B\u0441\u0430\u0442 \u0435\u0442\u0456\u043B\u0433\u0435\u043D \u043C\u04D9\u043D \u0435\u043C\u0435\u0441.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u0430\u0440\u0442\u044B\u049B \u0431\u043E\u043B\u0443\u044B \u043C\u04AF\u043C\u043A\u0456\u043D \u0435\u043C\u0435\u0441 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u043A\u0435\u043C \u043D\u0435\u043C\u0435\u0441\u0435 \u0442\u0435\u04A3 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0424\u0430\u0439\u043B \u043F\u0456\u0448\u0456\u043C\u0434\u0435\u0440\u0456 \u0440\u04B1\u049B\u0441\u0430\u0442 \u0435\u0442\u0456\u043B\u043C\u0435\u0439\u0434\u0456.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u0442\u0438\u043F\u0442\u0435 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u043A\u0435\u043C \u0431\u043E\u043B\u0443\u044B \u043C\u04AF\u043C\u043A\u0456\u043D \u0435\u043C\u0435\u0441 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u043A\u0435\u043C \u0434\u0435\u0433\u0435\u043D\u0434\u0435 \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u0440\u04B1\u049B\u0441\u0430\u0442 \u0435\u0442\u0456\u043B\u043C\u0435\u0439\u0434\u0456 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u0441\u0430\u043D \u0431\u043E\u043B\u0443\u044B \u043A\u0435\u0440\u0435\u043A.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u0442\u0430\u043B\u0430\u043F \u0435\u0442\u0456\u043B\u0435\u0434\u0456.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} -\u0434\u0435\u043D \u0431\u0430\u0441\u0442\u0430\u043B\u043C\u0430\u0439\u0434\u044B ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0416\u0430\u0440\u0430\u043C\u0434\u044B URL \u043C\u0435\u043A\u0435\u043D\u0436\u0430\u0439\u044B\u043D \u049B\u043E\u0441\u044B\u04A3\u044B\u0437.`;\n        /* </i18n> */\n    },\n};\n\nvar kk = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$e,\n    validation: validation$e\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$d = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\uCD94\uAC00',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\uC81C\uAC70',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\uBAA8\uB450 \uC81C\uAC70',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\uBAA8\uB4E0 \uAC12\uC744 \uCC44\uC6CC\uC8FC\uC138\uC694',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\uC81C\uCD9C\uD558\uAE30',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\uC120\uD0DD\uB41C \uD30C\uC77C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$d = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `${name} \uC62C\uBC14\uB978 \uAC12\uC744 \uC120\uD0DD \uD574\uC8FC\uC138\uC694`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} \uC774\uD6C4\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \uBBF8\uB798\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \uC54C\uD30C\uBCB3 \uBB38\uC790\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \uBB38\uC790\uC640 \uC22B\uC790\uB9CC \uD3EC\uD568\uB420 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \uBB38\uC790\uC640 \uACF5\uBC31\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} \uC774\uC804\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \uACFC\uAC70\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${a}\uC640 ${b} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \uC77C\uCE58\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \uC720\uD6A8\uD55C \uB0A0\uC9DC\uAC00 \uC544\uB2D9\uB2C8\uB2E4. ${args[0]}\uACFC \uAC19\uC740 \uD615\uC2DD\uC744 \uC0AC\uC6A9\uD574\uC8FC\uC138\uC694`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} ${date(args[0])}\uC5D0\uC11C ${date(args[1])} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\uC62C\uBC14\uB978 \uC774\uBA54\uC77C \uC8FC\uC18C\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}\uB85C \uB05D\uB098\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \uD558\uB098 \uC774\uC0C1\uC758 \uBB38\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}\uC790 \uC774\uD558\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min} \uBB38\uC790\uBCF4\uB2E4 \uD06C\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} ${min}\uC5D0\uC11C ${max}\uC790 \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${args[0]} ${name} \uCD08\uACFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]}\uBCF4\uB2E4 \uC791\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\uD30C\uC77C \uD615\uC2DD\uC774 \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} \uC720\uD615\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${args[0]} ${name}\uBCF4\uB2E4 \uC791\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} \uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `${value}\" \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uB294 ${name}\uC785\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \uD544\uC218 \uAC12\uC785\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}\uB85C \uC2DC\uC791\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\uC62C\uBC14\uB978 URL\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694`;\n        /* </i18n> */\n    },\n};\n\nvar ko = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$d,\n    validation: validation$d\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$c = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Toevoegen',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Verwijder',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Verwijder alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, niet alle velden zijn correct ingevuld.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Versturen',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Geen bestand gekozen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$c = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepteer de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moet na ${date(args[0])} zijn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in de toekomst liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mag alleen alfabetische tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mag alleen letters en cijfers bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kunnen alleen letters en spaties bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moet v\u00F3\u00F3r ${date(args[0])} vallen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in het verleden zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit veld is onjuist geconfigureerd en kan niet worden verzonden.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moet tussen ${a} en ${b} liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt niet overeen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is geen geldige datum, gebruik de notatie ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit veld is onjuist geconfigureerd en kan niet worden verzonden';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moet tussen ${date(args[0])} en ${date(args[1])} liggen`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Vul een geldig e-mailadres in.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} eindigt niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moet minimaal \u00E9\u00E9n teken zijn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moet groter zijn dan of gelijk zijn aan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moet tussen de ${min} en ${max} tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mag niet meer dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Geen bestandsformaten toegestaan.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moet van het type: ${args[0]} zijn`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mag niet minder dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moet minimaal ${args[0]} zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is geen toegestane ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moet een getal zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is verplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begint niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Voeg een geldige url toe.`;\n        /* </i18n> */\n    },\n};\n\nvar nl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$c,\n    validation: validation$c\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$b = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Dodaj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Usu\u0144',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Usu\u0144 wszystko',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Nie wszystkie pola zosta\u0142y wype\u0142nione poprawnie.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Wy\u015Blij',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nie wybrano pliku',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$b = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Prosz\u0119 zaakceptowa\u0107 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} musi by\u0107 po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 w przysz\u0142o\u015Bci.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `Pole ${sentence(name)} mo\u017Ce zawiera\u0107 tylko znaki alfabetyczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `Pole ${sentence(name)} mo\u017Ce zawiera\u0107 tylko znaki alfanumeryczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `Pole ${sentence(name)} mog\u0105 zawiera\u0107 tylko litery i spacje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} musi by\u0107 przed ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 w przesz\u0142o\u015Bci.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `Warto\u015B\u0107 pola ${sentence(name)} musi by\u0107 pomi\u0119dzy ${a} i ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nie pokrywa si\u0119.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `Warto\u015B\u0107 pola ${sentence(name)} nie jest poprawn\u0105 dat\u0105, prosz\u0119 u\u017Cy\u0107 formatu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'To pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `Data w polu ${sentence(name)} musi by\u0107 pomi\u0119dzy ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Prosz\u0119 wpisa\u0107 poprawny adres email.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `Pole ${sentence(name)} nie ko\u0144czy si\u0119 na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `Pole ${sentence(name)} nie jest dozwolon\u0105 warto\u015Bci\u0105.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `Pole ${sentence(name)} musi posiada\u0107 minimum jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `Pole ${sentence(name)} musi zawiera\u0107 ${max} lub mniej znak\u00F3w.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `Pole ${sentence(name)} musi zawiera\u0107 ${min} lub wi\u0119cej znak\u00F3w.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `Pole ${sentence(name)} musi mie\u0107 ${min}-${max} znak\u00F3w.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `Pole ${sentence(name)} zawiera niedozwolone znaki.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nie mo\u017Cna mie\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `Warto\u015B\u0107 pola ${sentence(name)} musi by\u0107 mniejsza lub r\u00F3wna ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nie podano dozwolonych typ\u00F3w plik\u00F3w.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 typem: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Musisz poda\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return ` Musisz poda\u0107 conajmniej ${args[0]} ${sentence(name)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `Warto\u015B\u0107 pola ${name} jest niedozwolona.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} musi by\u0107 numerem.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `Pole ${sentence(name)} jest wymagane.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `Warto\u015Bc pola ${sentence(name)} nie zaczyna si\u0119 od ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Prosz\u0119 poda\u0107 prawid\u0142owy adres url.`;\n        /* </i18n> */\n    },\n};\n\nvar pl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$b,\n    validation: validation$b\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$a = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Adicionar',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remover',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Deletar tudo',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Desculpe, nem todos os campos foram preenchidos corretamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nenhum arquivo',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$a = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Por favor aceite o ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser no futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} s\u00F3 pode conter caracteres do alfabeto.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} s\u00F3 pode ter letras e n\u00FAmeros.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} s\u00F3 podem conter letras e espa\u00E7os.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser anterior a data atual.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `O campo foi configurado incorretamente e n\u00E3o pode ser enviado.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve estar entre ${args[0]} e ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} n\u00E3o confere.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} n\u00E3o \u00E9 uma data v\u00E1lida, por favor use o formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'O campo foi configurado incorretamente e n\u00E3o pode ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve ser entre ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Por favor informe um e-mail v\u00E1lido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o termina com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o \u00E9 um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve ter ao menos um caractere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} n\u00E3o pode ter mais que ${max} caracteres.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve ter no m\u00EDnimo ${min} caracteres.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve ter entre ${min} e ${max} caracteres.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} n\u00E3o \u00E9 um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `N\u00E3o pode ter mais que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ser igual ou menor que ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nenhum formato de arquivo permitido.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve ser do tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `N\u00E3o pode ter menos que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ter pelo menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D n\u00E3o permite ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve ser um n\u00FAmero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u00E9 obrigat\u00F3rio.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o come\u00E7a com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Por favor informe um url v\u00E1lido.`;\n        /* </i18n> */\n    },\n};\n\nvar pt = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$a,\n    validation: validation$a\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$9 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Ad\u0103ugare',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Elimin\u0103',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Elimin\u0103 tot',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pare r\u0103u, unele c\u00E2mpuri nu sunt corect completate.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Trimite',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nu este selectat nici un fi\u0219ier',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$9 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Te rog accept\u0103 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} trebuie s\u0103 fie dup\u0103 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} trebuie sa fie \u00EEn viitor.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} poate con\u021Bine doar caractere alafetice.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} poate con\u021Bine doar litere \u0219i numere.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} poate con\u021Bine doar litere \u0219i spa\u021Bii.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} trebuie s\u0103 precead\u0103 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} trebuie s\u0103 fie \u00EEn trecut.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `C\u00E2mpul a fost configurat incorect \u0219i nu poate fi trimis.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} trebuie s\u0103 fie \u00EEntre ${a} \u0219i ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nu se potrive\u0219te.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nu este valid\u0103, te rog folo\u0219te formatul ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'C\u00E2mpul a fost incorect configurat \u0219i nu poate fi trimis.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} trebuie s\u0103 fie \u00EEntre ${date(args[0])} \u0219i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Te rog folose\u0219te o adres\u0103 de email valid\u0103.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nu se termin\u0103 cu ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nu este o valoare acceptat\u0103.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} trebuie sa con\u021Bin\u0103 cel pu\u021Bin un caracter.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} trebuie sa aib\u0103 cel mult ${max} caractere.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} trebuie s\u0103 aib\u0103 cel pu\u021Bin ${min} caractere.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} trebuie s\u0103 aib\u0103 \u00EEntre ${min} \u0219i ${max} caractere.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nu este o valoare acceptat\u0103.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nu poate avea mai mult decat ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} trebuie s\u0103 fie cel mult egal cu ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Tipul de fi\u0219ier neacceptat.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} trebuie s\u0103 fie de tipul: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Nu poate avea mai pu\u021Bin dec\u00E2t ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} trebuie s\u0103 fie cel pu\u021Bin ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nu este o valoare accept\u0103 pentru ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} trebuie s\u0103 fie un num\u0103r.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} este necesar.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nu \u00EEncepe cu ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Te rog include o adres\u0103 web valid\u0103`;\n        /* </i18n> */\n    },\n};\n\nvar ro = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$9,\n    validation: validation$9\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$8 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0423\u0434\u0430\u043B\u0438\u0442\u044C',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0423\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0435',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0418\u0437\u0432\u0438\u043D\u0438\u0442\u0435, \u043D\u0435 \u0432\u0441\u0435 \u043F\u043E\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u044B \u0432\u0435\u0440\u043D\u043E.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0424\u0430\u0439\u043B \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$8 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0438\u0442\u0435 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043F\u043E\u0437\u0436\u0435 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u0446\u0438\u0444\u0440\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u043C\u043E\u0433\u0443\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0440\u0430\u043D\u044C\u0448\u0435 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${a} \u0438 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0432\u0435\u0440\u043D\u0443\u044E \u0434\u0430\u0442\u0443. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${date(args[0])} \u0438 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u044D\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u044B\u0439 \u0430\u0434\u0440\u0435\u0441.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0434\u043E\u043B\u0436\u043D\u043E \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u043F\u043E\u0434\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C \u043E\u0434\u0438\u043D \u0441\u0438\u043C\u0432\u043E\u043B.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${min} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${min} \u0438 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C\u0438.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D\u044B \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0430\u0432\u0435\u043C\u044B\u0435 \u0444\u043E\u0440\u043C\u0430\u0442\u044B \u0444\u0430\u0439\u043B\u0430.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `\u0424\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430 \u0432 \u043F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C: ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u0435\u0435, \u0447\u0435\u043C ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432 \u043F\u043E\u043B\u0435 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u0447\u0438\u0441\u043B\u043E\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0434\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u044F.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 URL \u0430\u0434\u0440\u0435\u0441.`;\n        /* </i18n> */\n    },\n};\n\nvar ru = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$8,\n    validation: validation$8\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$7 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Dodaj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Odstrani',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Odstrani vse',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Nekatera polja niso pravilno izpolnjena.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Po\u0161lji',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nobena datoteka ni izbrana',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$7 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Prosimo popravite ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti v prihodnosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} lahko vsebuje samo znake abecede.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} lahko vsebuje samo \u010Drke in \u0161tevilke.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} lahko vsebuje samo \u010Drke in presledke.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti pred ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti v preteklosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `To polje je narobe nastavljeno in ne mora biti izpolnjeno.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mora biti med ${a} in ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} se ne ujema.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ni pravilen datum, prosimo uporabite format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'To polje je narobe nastavljeno in ne mora biti izpolnjeno.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mora biti med ${date(args[0])} in ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Vnesite veljaven e-po\u0161tni naslov.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} se mora ko\u010Dati z ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ni dovoljena vrednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mora vsebovati vsaj en znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mora vsebovati najve\u010D ${max} znakov.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mora vsebovati vsaj ${min} znakov.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} mora vsebovati med ${min} in ${max} znakov.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ni dovoljena vrednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Najve\u010D je ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} je lahko najve\u010D ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nobena vrsta datoteke ni dovoljena.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} mora biti tipa: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Najmanj ${args[0]} ${name} je dovoljenih.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mora biti vsaj ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ni dovoljen(a/o) ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mora biti \u0161tevilka.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je zahtevan(o/a).`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} se mora za\u010Deti z ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Vnesite veljavno povezavo.`;\n        /* </i18n> */\n    },\n};\n\nvar sl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$7,\n    validation: validation$7\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$6 = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: 'Dodaj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ukloni',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Ukloni sve',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pojedina polja nisu ispravno ispunjena.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Po\u0161alji',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Fajl nije odabran',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$6 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Molimo prihvatite ${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti posle ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u buduc\u0301nosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mo\u017Ee da sadr\u017Ei samo abecedne znakove.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mo\u017Ee da sadr\u017Ei samo slova i brojeve.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mo\u017Ee da sadr\u017Ei samo slova i razmake.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti pre ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u pro\u0161losti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Ovo polje je pogre\u0161no konfigurisano i ne mo\u017Ee se poslati.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mora biti izme\u0111u ${a} i ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} se ne podudara.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nije va\u017Eec\u0301i datum, molimo Vas koristite format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ovo polje je pogre\u0161no konfigurisano i ne mo\u017Ee se poslati';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mora biti izme\u0111u ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Unesite ispravnu e-mail adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} se ne zavr\u0161ava sa ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nije dozvoljena vrednost`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mora biti najmanje jedan karakter.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mora biti manji ili jednaki od ${max} karaktera.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mora biti vec\u0301i ili jednaki od ${min} karaktera.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} mora biti izme\u0111u ${min} i ${max} karaktera.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nije dozvoljena vrednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne mo\u017Ee imati vi\u0161e od ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mora biti manji ili jednaki od ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nisu dozvoljeni formati datoteka.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} mora biti tipa: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Ne mo\u017Ee imati manje od ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mora da ima najmanje ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nije dozvoljeno ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mora biti broj.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je obavezno polje.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne po\u010Dinje sa ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Molimo unesite va\u017Eec\u0301i URL.`;\n        /* </i18n> */\n    },\n};\n\nvar sr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$6,\n    validation: validation$6\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$5 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ta bort',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Ta bort alla',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Tyv\u00E4rr \u00E4r inte alla f\u00E4lt korrekt ifyllda',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Skicka',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ingen fil vald',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$5 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Var god acceptera ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} m\u00E5ste vara efter ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} m\u00E5ste vara fram\u00E5t i tiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} kan enbart inneh\u00E5lla bokst\u00E4ver i alfabetet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} kan bara inneh\u00E5lla bokst\u00E4ver och siffror.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kan bara inneh\u00E5lla bokst\u00E4ver och blanksteg.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} m\u00E5ste vara f\u00F6re ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} m\u00E5ste vara bak\u00E5t i tiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Det h\u00E4r f\u00E4ltet st\u00E4lldes inte in korrekt och kan inte anv\u00E4ndas.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} m\u00E5ste vara mellan ${a} och ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} matchar inte.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u00E4r inte ett giltigt datum, var god anv\u00E4nd formatet ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Det h\u00E4r f\u00E4ltet st\u00E4lldes inte in korrekt och kan inte anv\u00E4ndas';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} m\u00E5ste vara mellan ${date(args[0])} och ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Var god fyll i en giltig e-postadress.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} slutar inte med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u00E4r inte ett godk\u00E4nt v\u00E4rde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} m\u00E5ste ha minst ett tecken.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} m\u00E5ste vara ${max} tecken eller f\u00E4rre.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} m\u00E5ste vara ${min} tecken eller fler.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} m\u00E5ste vara mellan ${min} och ${max} tecken.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u00E4r inte ett godk\u00E4nt v\u00E4rde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Kan inte ha mer \u00E4n ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} m\u00E5ste vara ${args[0]} eller mindre.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Inga filtyper till\u00E5tna.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} m\u00E5ste vara av filtypen: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Kan inte ha mindre \u00E4n ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} m\u00E5ste vara minst ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u00E4r inte ett godk\u00E4nt ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} m\u00E5ste vara en siffra.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u00E4r obligatoriskt.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} b\u00F6rjar inte med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Var god fyll i en giltig l\u00E4nk.`;\n        /* </i18n> */\n    },\n};\n\nvar sv = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$5,\n    validation: validation$5\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$4 = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: '\u0418\u043B\u043E\u0432\u0430 \u043A\u0430\u0440\u0434\u0430\u043D',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0425\u043E\u0440\u0438\u04B7 \u043A\u0430\u0440\u0434\u0430\u043D',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u04B2\u0430\u043C\u0430\u0440\u043E \u0445\u043E\u0440\u0438\u04B7 \u043A\u0443\u043D\u0435\u0434',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0411\u0443\u0431\u0430\u0445\u0448\u0435\u0434, \u043D\u0430 \u04B3\u0430\u043C\u0430 \u043C\u0430\u0439\u0434\u043E\u043D\u04B3\u043E \u0434\u0443\u0440\u0443\u0441\u0442 \u043F\u0443\u0440 \u043A\u0430\u0440\u0434\u0430 \u0448\u0443\u0434\u0430\u0430\u043D\u0434.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u041F\u0435\u0448\u043D\u0438\u04B3\u043E\u0434 \u043A\u0443\u043D\u0435\u0434',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u042F\u0433\u043E\u043D \u0444\u0430\u0439\u043B \u0438\u043D\u0442\u0438\u0445\u043E\u0431 \u043D\u0430\u0448\u0443\u0434\u0430\u0430\u0441\u0442',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$4 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u041B\u0443\u0442\u0444\u0430\u043D ${name}-\u0440\u043E \u049B\u0430\u0431\u0443\u043B \u043A\u0443\u043D\u0435\u0434`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0431\u043E\u044F\u0434 \u043F\u0430\u0441 \u0430\u0437 ${date(args[0])} \u0431\u043E\u0448\u0430\u0434.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0434\u0430\u0440 \u043E\u044F\u043D\u0434\u0430 \u0431\u043E\u0448\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u043C\u0435\u0442\u0430\u0432\u043E\u043D\u0430\u0434 \u0442\u0430\u043D\u04B3\u043E \u0430\u043B\u043E\u043C\u0430\u0442\u04B3\u043E\u0438 \u0430\u043B\u0438\u0444\u0431\u043E\u0440\u043E \u0434\u0430\u0440 \u0431\u0430\u0440 \u0433\u0438\u0440\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u043C\u0435\u0442\u0430\u0432\u043E\u043D\u0430\u0434 \u0442\u0430\u043D\u04B3\u043E \u04B3\u0430\u0440\u0444\u04B3\u043E \u0432\u0430 \u0440\u0430\u049B\u0430\u043C\u04B3\u043E\u0440\u043E \u0434\u0430\u0440 \u0431\u0430\u0440 \u0433\u0438\u0440\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u043C\u0435\u0442\u0430\u0432\u043E\u043D\u0430\u0434 \u0442\u0430\u043D\u04B3\u043E \u04B3\u0430\u0440\u0444\u04B3\u043E \u0432\u0430 \u0444\u043E\u0441\u0438\u043B\u0430\u04B3\u043E\u0440\u043E \u0434\u0430\u0440 \u0431\u0430\u0440 \u0433\u0438\u0440\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0431\u043E\u044F\u0434 \u043F\u0435\u0448 \u0430\u0437 ${date(args[0])} \u0431\u043E\u0448\u0430\u0434.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0434\u0430\u0440 \u0433\u0443\u0437\u0430\u0448\u0442\u0430 \u0431\u043E\u0448\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u0418\u043D \u043C\u0430\u0439\u0434\u043E\u043D \u043D\u043E\u0434\u0443\u0440\u0443\u0441\u0442 \u0442\u0430\u043D\u0437\u0438\u043C \u0448\u0443\u0434\u0430\u0430\u0441\u0442 \u0432\u0430 \u043E\u043D\u0440\u043E \u043F\u0435\u0448\u043D\u0438\u04B3\u043E\u0434 \u043A\u0430\u0440\u0434\u0430\u043D \u0493\u0430\u0439\u0440\u0438\u0438\u043C\u043A\u043E\u043D \u0430\u0441\u0442.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0434\u0430\u0440 \u0431\u0430\u0439\u043D\u0438 ${a} \u0432\u0430 ${b} \u0431\u043E\u0448\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u043C\u0443\u0432\u043E\u0444\u0438\u049B\u0430\u0442 \u043D\u0430\u043C\u0435\u043A\u0443\u043D\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u0441\u0430\u043D\u0430\u0438 \u0434\u0443\u0440\u0443\u0441\u0442 \u043D\u0435\u0441\u0442, \u043B\u0443\u0442\u0444\u0430\u043D \u0444\u043E\u0440\u043C\u0430\u0442\u0438 ${args[0]}-\u0440\u043E \u0438\u0441\u0442\u0438\u0444\u043E\u0434\u0430 \u0431\u0430\u0440\u0435\u0434`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u0418\u043D \u043C\u0430\u0439\u0434\u043E\u043D \u043D\u043E\u0434\u0443\u0440\u0443\u0441\u0442 \u0442\u0430\u043D\u0437\u0438\u043C \u0448\u0443\u0434\u0430\u0430\u0441\u0442 \u0432\u0430 \u043E\u043D\u0440\u043E \u043F\u0435\u0448\u043D\u0438\u04B3\u043E\u0434 \u043A\u0430\u0440\u0434\u0430\u043D \u0493\u0430\u0439\u0440\u0438\u0438\u043C\u043A\u043E\u043D \u0430\u0441\u0442';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0434\u0430\u0440 \u0431\u0430\u0439\u043D\u0438 ${date(args[0])} \u0432\u0430 ${date(args[1])} \u0431\u043E\u0448\u0430\u0434`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u041B\u0443\u0442\u0444\u0430\u043D \u043D\u0438\u0448\u043E\u043D\u0430\u0438 \u0438\u043C\u0435\u0439\u043B\u0438 \u0430\u043C\u0430\u043B\u043A\u0443\u043D\u0430\u043D\u0434\u0430\u0440\u043E \u0432\u043E\u0440\u0438\u0434 \u043D\u0430\u043C\u043E\u0435\u0434.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E ${list(args)} \u0431\u0430 \u043E\u0445\u0438\u0440 \u043D\u0430\u043C\u0435\u0440\u0430\u0441\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0430\u0440\u0437\u0438\u0448\u0438 \u0438\u04B7\u043E\u0437\u0430\u0442\u0434\u043E\u0434\u0430\u0448\u0443\u0434\u0430 \u043D\u0435\u0441\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u0431\u043E\u044F\u0434 \u04B3\u0430\u0434\u0434\u0438 \u0430\u049B\u049B\u0430\u043B \u044F\u043A \u0430\u043B\u043E\u043C\u0430\u0442 \u0431\u043E\u0448\u0430\u0434.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0430\u0437 ${max} \u0430\u043B\u043E\u043C\u0430\u0442 \u043A\u0430\u043C\u0442\u0430\u0440 \u0451 \u0431\u0430\u0440\u043E\u0431\u0430\u0440 \u0431\u043E\u0448\u0430\u0434.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0430\u0437 ${min} \u0430\u043B\u043E\u043C\u0430\u0442 \u0437\u0438\u0451\u0434 \u0451 \u0431\u0430\u0440\u043E\u0431\u0430\u0440 \u0431\u043E\u0448\u0430\u0434.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0434\u0430\u0440 \u0431\u0430\u0439\u043D\u0438 ${min} \u0432\u0430 ${max} \u0430\u043B\u043E\u043C\u0430\u0442 \u0431\u043E\u0448\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0430\u0440\u0437\u0438\u0448\u0438 \u0438\u04B7\u043E\u0437\u0430\u0442\u0434\u043E\u0434\u0430\u0448\u0443\u0434\u0430 \u043D\u0435\u0441\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u0417\u0438\u0451\u0434\u0430 \u0430\u0437 ${args[0]} ${name} \u0434\u043E\u0448\u0442\u0430 \u043D\u0430\u043C\u0435\u0442\u0430\u0432\u043E\u043D\u0430\u0434.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0430\u0437 ${args[0]} \u043A\u0430\u043C\u0442\u0430\u0440 \u0451 \u0431\u0430\u0440\u043E\u0431\u0430\u0440 \u0431\u043E\u0448\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u042F\u0433\u043E\u043D \u0444\u043E\u0440\u043C\u0430\u0442\u0438 \u0444\u0430\u0439\u043B \u0438\u04B7\u043E\u0437\u0430\u0442 \u0434\u043E\u0434\u0430 \u043D\u0430\u043C\u0435\u0448\u0430\u0432\u0430\u0434.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0447\u0443\u043D\u0438\u043D \u043D\u0430\u043C\u0443\u0434 \u0431\u043E\u0448\u0430\u0434: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u041A\u0430\u043C\u0442\u0430\u0440 \u0430\u0437 ${args[0]} ${name} \u0434\u043E\u0448\u0442\u0430 \u043D\u0430\u043C\u0435\u0442\u0430\u0432\u043E\u043D\u0430\u0434.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u04B3\u0430\u0434\u0434\u0438 \u0430\u049B\u049B\u0430\u043B ${args[0]} \u0431\u043E\u0448\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" ${name} \u0438\u04B7\u043E\u0437\u0430\u0442 \u0434\u043E\u0434\u0430 \u043D\u0430\u043C\u0435\u0448\u0430\u0432\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u0431\u043E\u044F\u0434 \u0440\u0430\u049B\u0430\u043C \u0431\u043E\u0448\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u043B\u043E\u0437\u0438\u043C \u0430\u0441\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0431\u043E ${list(args)} \u043E\u0493\u043E\u0437 \u043D\u0430\u043C\u0435\u0448\u0430\u0432\u0430\u0434.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u041B\u0443\u0442\u0444\u0430\u043D URL-\u0438 \u0434\u0443\u0440\u0443\u0441\u0442\u0440\u043E \u0434\u043E\u0445\u0438\u043B \u043A\u0443\u043D\u0435\u0434.`;\n        /* </i18n> */\n    },\n};\n\nvar tg = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$4,\n    validation: validation$4\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$3 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\u0E40\u0E1E\u0E34\u0E48\u0E21',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0E40\u0E2D\u0E32\u0E2D\u0E2D\u0E01',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0E40\u0E2D\u0E32\u0E2D\u0E2D\u0E01\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0E02\u0E2D\u0E2D\u0E20\u0E31\u0E22 \u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E1A\u0E32\u0E07\u0E0A\u0E48\u0E2D\u0E07\u0E17\u0E35\u0E48\u0E01\u0E23\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u0E2A\u0E48\u0E07',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0E22\u0E31\u0E07\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E1F\u0E25\u0E4C',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$3 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u0E01\u0E23\u0E38\u0E13\u0E32\u0E22\u0E2D\u0E21\u0E23\u0E31\u0E1A ${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E25\u0E31\u0E07\u0E08\u0E32\u0E01 ${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E17\u0E35\u0E48\u0E22\u0E31\u0E07\u0E44\u0E21\u0E48\u0E21\u0E32\u0E16\u0E36\u0E07`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E40\u0E1B\u0E47\u0E19\u0E44\u0E14\u0E49\u0E41\u0E04\u0E48\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E40\u0E17\u0E48\u0E32\u0E19\u0E31\u0E49\u0E19`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E40\u0E1B\u0E47\u0E19\u0E44\u0E14\u0E49\u0E41\u0E04\u0E48\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E41\u0E25\u0E30\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E40\u0E17\u0E48\u0E32\u0E19\u0E31\u0E49\u0E19`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E40\u0E1B\u0E47\u0E19\u0E44\u0E14\u0E49\u0E41\u0E04\u0E48\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E41\u0E25\u0E30\u0E40\u0E27\u0E49\u0E19\u0E27\u0E23\u0E23\u0E04\u0E40\u0E17\u0E48\u0E32\u0E19\u0E31\u0E49\u0E19`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E17\u0E35\u0E48\u0E21\u0E32\u0E01\u0E48\u0E2D\u0E19 ${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E17\u0E35\u0E48\u0E1C\u0E48\u0E32\u0E19\u0E21\u0E32\u0E41\u0E25\u0E49\u0E27`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u0E0A\u0E48\u0E2D\u0E07\u0E19\u0E35\u0E49\u0E16\u0E39\u0E01\u0E15\u0E31\u0E49\u0E07\u0E04\u0E48\u0E32\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07 \u0E41\u0E25\u0E30\u0E08\u0E30\u0E44\u0E21\u0E48\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E2A\u0E48\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E14\u0E49`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E04\u0E48\u0E32\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07 ${a} \u0E41\u0E25\u0E30 ${b}`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E19`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u0E44\u0E21\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E17\u0E35\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07 \u0E01\u0E23\u0E38\u0E13\u0E32\u0E01\u0E23\u0E2D\u0E01\u0E15\u0E32\u0E21\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u0E0A\u0E48\u0E2D\u0E07\u0E19\u0E35\u0E49\u0E16\u0E39\u0E01\u0E15\u0E31\u0E49\u0E07\u0E04\u0E48\u0E32\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07 \u0E41\u0E25\u0E30\u0E08\u0E30\u0E44\u0E21\u0E48\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E2A\u0E48\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E14\u0E49';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07 ${date(args[0])} \u0E41\u0E25\u0E30 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u0E01\u0E23\u0E38\u0E13\u0E32\u0E01\u0E23\u0E2D\u0E01\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25\u0E17\u0E35\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 ${list(args)}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E04\u0E48\u0E32\u0E17\u0E35\u0E48\u0E2D\u0E19\u0E38\u0E0D\u0E32\u0E15\u0E43\u0E2B\u0E49\u0E01\u0E23\u0E2D\u0E01`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E04\u0E27\u0E32\u0E21\u0E22\u0E32\u0E27\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E04\u0E27\u0E32\u0E21\u0E22\u0E32\u0E27\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19 ${max} \u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E04\u0E27\u0E32\u0E21\u0E22\u0E32\u0E27 ${min} \u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23\u0E02\u0E36\u0E49\u0E19\u0E44\u0E1B`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E04\u0E27\u0E32\u0E21\u0E22\u0E32\u0E27\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07 ${min} \u0E41\u0E25\u0E30 ${max} \u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E04\u0E48\u0E32\u0E17\u0E35\u0E48\u0E2D\u0E19\u0E38\u0E0D\u0E32\u0E15\u0E43\u0E2B\u0E49\u0E01\u0E23\u0E2D\u0E01`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u0E44\u0E21\u0E48\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32 ${args[0]} ${name} \u0E44\u0E14\u0E49`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19 ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0E44\u0E21\u0E48\u0E21\u0E35\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E2D\u0E07\u0E44\u0E1F\u0E25\u0E4C\u0E17\u0E35\u0E48\u0E2D\u0E19\u0E38\u0E0D\u0E32\u0E15';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E44\u0E1F\u0E25\u0E4C\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17 ${args[0]} \u0E40\u0E17\u0E48\u0E32\u0E19\u0E31\u0E49\u0E19`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u0E44\u0E21\u0E48\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32 ${args[0]} ${name} \u0E44\u0E14\u0E49`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E04\u0E48\u0E32\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22 ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E04\u0E48\u0E32 ${name} \u0E17\u0E35\u0E48\u0E2D\u0E19\u0E38\u0E0D\u0E32\u0E15\u0E43\u0E2B\u0E49\u0E01\u0E23\u0E2D\u0E01`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E40\u0E17\u0E48\u0E32\u0E19\u0E31\u0E49\u0E19`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `\u0E01\u0E23\u0E38\u0E13\u0E32\u0E01\u0E23\u0E2D\u0E01 ${sentence(name)}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0E08\u0E30\u0E15\u0E49\u0E2D\u0E07\u0E40\u0E23\u0E34\u0E48\u0E21\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 ${list(args)}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E25\u0E34\u0E07\u0E01\u0E4C\u0E43\u0E2B\u0E49\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;\n        /* </i18n> */\n    },\n};\n\nvar th = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$3,\n    validation: validation$3\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$2 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Ekle',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Kald\u0131r',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hepsini kald\u0131r',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maalesef, t\u00FCm alanlar do\u011Fru doldurulmad\u0131.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'G\u00F6nder',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Dosya yok',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$2 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `L\u00FCtfen ${name}'yi kabul edin.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])}'den sonra olmal\u0131d\u0131r.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} gelecekte bir zaman olmal\u0131d\u0131r.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler ve say\u0131 i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} yaln\u0131zca harf ve bo\u015Fluk i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} tarihinden \u00F6nce olmal\u0131.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ge\u00E7mi\u015Fte olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\u00F6nderilemez.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${args[0]} ve ${args[1]} aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} e\u015Fle\u015Fmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ge\u00E7erli bir tarih de\u011Fil, l\u00FCtfen ${args[0]} bi\u00E7imini kullan\u0131n.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\u00F6nderilemez.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}, ${date(args[0])} ve ${date(args[1])} aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'L\u00FCtfen ge\u00E7erli bir e-mail adresi girin.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile bitmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} en az\u0131ndan bir karakter uzunlu\u011Funda olmal\u0131.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}'e e\u015Fit veya daha k\u00FC\u00E7\u00FCk olmal\u0131.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min}'e e\u015Fit veya daha b\u00FCy\u00FCk olmal\u0131.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}, ${min} ve ${max} karakter uzunlu\u011Fu aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha uzun olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda veya ona e\u015Fit olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Hi\u00E7bir dosya t\u00FCr\u00FCne izin verilmez.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u015Fu tiplerden biri olmal\u0131: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha k\u0131sa olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ${name} olamaz.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} say\u0131 olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} gerekli.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile ba\u015Flam\u0131yor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `L\u00FCtfen ge\u00E7erli bir url dahil edin.`;\n        /* </i18n> */\n    },\n};\n\nvar tr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$2,\n    validation: validation$2\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$1 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Th\u00EAm',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Xo\u00E1',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Xo\u00E1 t\u1EA5t c\u1EA3',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Xin l\u1ED7i, kh\u00F4ng ph\u1EA3i t\u1EA5t c\u1EA3 c\u00E1c tr\u01B0\u1EDDng \u0111\u1EC1u \u0111\u01B0\u1EE3c nh\u1EADp \u0111\u00FAng.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'G\u1EEDi',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ch\u01B0a ch\u1ECDn file',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$1 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `H\u00E3y \u0111\u1ED3ng \u00FD v\u1EDBi ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i sau ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i trong t\u01B0\u01A1ng lai.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} c\u00F3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\u00E1c ch\u1EEF c\u00E1i alphabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} c\u00F3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\u00E1c ch\u1EEF c\u00E1i v\u00E0 ch\u1EEF s\u1ED1.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} ch\u1EC9 c\u00F3 th\u1EC3 ch\u1EE9a c\u00E1c ch\u1EEF c\u00E1i v\u00E0 kho\u1EA3ng tr\u1EAFng.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i tr\u01B0\u1EDBc ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i trong qu\u00E1 kh\u1EE9.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Tr\u01B0\u1EDDng n\u00E0y \u0111\u00E3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\u00E0 kh\u00F4ng th\u1EC3 g\u1EEDi.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa ${a} v\u00E0 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} kh\u00F4ng kh\u1EDBp.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} kh\u00F4ng ph\u1EA3i ng\u00E0y h\u1EE3p l\u1EC7, h\u00E3y s\u1EED d\u1EE5ng \u0111\u1ECBnh d\u1EA1ng ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Tr\u01B0\u1EDDng n\u00E0y \u0111\u00E3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\u00E0 kh\u00F4ng th\u1EC3 g\u1EEDi.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa kho\u1EA3ng t\u1EEB ${date(args[0])} \u0111\u1EBFn ${date(args[1])}.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'H\u00E3y nh\u1EADp m\u1ED9t \u0111\u1ECBa ch\u1EC9 email h\u1EE3p l\u1EC7.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng k\u1EBFt th\u00FAc v\u1EDBi ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng ph\u1EA3i m\u1ED9t gi\u00E1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i thi\u1EC3u m\u1ED9t k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i \u0111a ${max} k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i thi\u1EC3u ${min} k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i \u0111a trong kho\u1EA3ng t\u1EEB ${min} \u0111\u1EBFn ${max} k\u00FD t\u1EF1.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} kh\u00F4ng ph\u1EA3i m\u1ED9t gi\u00E1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} kh\u00F4ng th\u1EC3 l\u1EDBn h\u01A1n ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i t\u1ED1i \u0111a b\u1EB1ng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0110\u1ECBnh d\u1EA1ng t\u1EC7p tin n\u00E0y kh\u00F4ng \u0111\u01B0\u1EE3c ph\u00E9p.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i l\u00E0 m\u1ED9t trong c\u00E1c d\u1EA1ng: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} kh\u00F4ng th\u1EC3 nh\u1ECF h\u01A1n ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i t\u1ED1i thi\u1EC3u b\u1EB1ng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" kh\u00F4ng ph\u1EA3i gi\u00E1 tr\u1ECB ${name} \u0111\u01B0\u1EE3c ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} ph\u1EA3i l\u00E0 m\u1ED9t s\u1ED1.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} l\u00E0 b\u1EAFt bu\u1ED9c.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng b\u1EAFt \u0111\u1EA7u v\u1EDBi ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `H\u00E3y nh\u1EADp m\u1ED9t URL h\u1EE3p l\u1EC7.`;\n        /* </i18n> */\n    },\n};\n\nvar vi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$1,\n    validation: validation$1\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '\u6DFB\u52A0',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u79FB\u9664',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u5BF9\u4E0D\u8D77\uFF0C\u6709\u4E9B\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u586B\u5199',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u63D0\u4EA4',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u8BF7\u63A5\u53D7${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u665A\u4E8E${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u672A\u6765\u7684\u65E5\u671F`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u5B57\u7B26`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u6570\u5B57`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)}\u53EA\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u7A7A\u683C`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u65E9\u4E8E${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u8FC7\u53BB\u7684\u65E5\u671F`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u5728${args[0]}\u548C${args[1]}\u4E4B\u95F4`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)}\u4E0D\u5339\u914D`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u65E5\u671F\uFF0C\u8BF7\u4F7F\u7528\u6B64\u683C\u5F0F${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}\u5FC5\u987B\u5728${date(args[0])}\u548C${date(args[1])}\u4E4B\u95F4`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u8BF7\u8F93\u5165\u4E00\u4E2A\u5408\u6CD5\u7684\u7535\u5B50\u90AE\u4EF6\u5730\u5740',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u5E76\u672A\u4EE5${list(args)}\u7ED3\u5C3E`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)}\u81F3\u5C11\u8981\u6709\u4E00\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u5C11\u4E8E\u6216\u7B49\u4E8E${max}\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u591A\u4E8E\u6216\u7B49\u4E8E${min}\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u6709${min}\u81F3${max}\u4E2A\u5B57\u7B26`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}\u4E0D\u80FD\u8D85\u8FC7${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u5C0F\u4E8E\u6216\u7B49\u4E8E${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u65E0\u5141\u8BB8\u7684\u6587\u4EF6\u683C\u5F0F';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u4E3A\u6B64\u7C7B\u578B\uFF1A${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}\u4E0D\u80FD\u5C11\u4E8E${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)}\u4E0D\u80FD\u5C0F\u4E8E${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D\u4E0D\u662F\u4E00\u4E2A\u88AB\u5141\u8BB8\u7684${name}`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u586B\u5199`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u6CA1\u6709\u4EE5${list(args)}\u5F00\u5934`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u8BF7\u5305\u542B\u4E00\u4E2A\u5408\u6CD5\u7684url`;\n        /* </i18n> */\n    },\n};\n\nvar zh = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui,\n    validation: validation\n});\n\n/**\n * Create a new internationalization plugin for FormKit.\n * @param locales - Creates the i18n plugin.\n * @public\n */\nfunction createI18nPlugin(registry) {\n    return function i18nPlugin(node) {\n        let localeKey = parseLocale(node.config.locale, registry);\n        let locale = localeKey ? registry[localeKey] : {};\n        /* If the locale prop changes, update the active locale */\n        node.on('prop:locale', ({ payload: lang }) => {\n            localeKey = parseLocale(lang, registry);\n            locale = localeKey ? registry[localeKey] : {};\n            // Run through all the messages in the store and update with new locale\n            node.store.touch();\n        });\n        node.on('prop:label', () => node.store.touch());\n        node.on('prop:validationLabel', () => node.store.touch());\n        /**\n         * Hook into the core text or t() hook to perform localization on the\n         * output of core functionality.\n         */\n        node.hook.text((fragment, next) => {\n            var _a, _b;\n            const key = ((_a = fragment.meta) === null || _a === void 0 ? void 0 : _a.messageKey) || fragment.key;\n            if (has(locale, fragment.type) && has(locale[fragment.type], key)) {\n                const t = locale[fragment.type][key];\n                if (typeof t === 'function') {\n                    fragment.value = Array.isArray((_b = fragment.meta) === null || _b === void 0 ? void 0 : _b.i18nArgs)\n                        ? t(...fragment.meta.i18nArgs) // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                        : t(fragment);\n                }\n                else {\n                    fragment.value = t;\n                }\n            }\n            return next(fragment);\n        });\n    };\n}\n/**\n * @param locale - An ISO 639-1 and (optionally) ISO 639-2 language tag. For\n * example these are valid locale keys:\n * zh\n * zh-CN\n * zh-HK\n * en\n * en-GB\n * @param availableLocales - An array of locales that may be valid.\n */\nfunction parseLocale(locale, availableLocales) {\n    if (has(availableLocales, locale)) {\n        return locale;\n    }\n    const [lang] = locale.split('-');\n    if (has(availableLocales, lang)) {\n        return lang;\n    }\n    for (const locale in availableLocales) {\n        return locale;\n    }\n    return false;\n}\n\n/**\n * Export all the available locales at once.\n * @public\n */\nconst locales = {\n    ar,\n    bg,\n    cs,\n    da,\n    de,\n    en,\n    es,\n    fa,\n    fi,\n    fr,\n    fy,\n    he,\n    hr,\n    hu,\n    id,\n    it,\n    ja,\n    kk,\n    ko,\n    nl,\n    pl,\n    pt,\n    ro,\n    ru,\n    sl,\n    sr,\n    sv,\n    tg,\n    th,\n    tr,\n    vi,\n    zh,\n};\n\nexport { ar, bg, createI18nPlugin, cs, da, date, de, en, es, fa, fi, fr, fy, he, hr, hu, id, it, ja, kk, ko, list, locales, nl, order, pl, pt, ro, ru, sentence, sl, sr, sv, tg, th, tr, vi, zh };\n", "import { FORMKIT_VERSION } from '@formkit/core';\n\n/**\n * A function to generate FormKit class functions from a javascript object\n * @param classes - An object of input types with nested objects of sectionKeys and class lists\n * @returns FormKitClassFunctions\n * @public\n */\nfunction generateClasses(classes) {\n    const classesBySectionKey = {};\n    Object.keys(classes).forEach((type) => {\n        Object.keys(classes[type]).forEach((sectionKey) => {\n            if (!classesBySectionKey[sectionKey]) {\n                classesBySectionKey[sectionKey] = {\n                    [type]: classes[type][sectionKey],\n                };\n            }\n            else {\n                classesBySectionKey[sectionKey][type] = classes[type][sectionKey];\n            }\n        });\n    });\n    Object.keys(classesBySectionKey).forEach((sectionKey) => {\n        const classesObject = classesBySectionKey[sectionKey];\n        classesBySectionKey[sectionKey] = function (node, sectionKey) {\n            return addClassesBySection(node, sectionKey, classesObject);\n        };\n    });\n    return classesBySectionKey;\n}\n/**\n * Updates a class list for a given sectionKey\n * @param node - the FormKit node being operated on\n * @param sectionKey - The section key to which the class list will be applied\n * @param classByType - Object containing mappings of class lists to section keys\n * @returns\n * @public\n */\nfunction addClassesBySection(node, _sectionKey, classesByType) {\n    const type = node.props.type;\n    let classList = '';\n    if (classesByType.global) {\n        classList += classesByType.global + ' ';\n    }\n    if (classesByType[type]) {\n        classList += classesByType[type];\n    }\n    const listParts = classList.split('$reset');\n    if (listParts.length > 1) {\n        return `$reset ${listParts[listParts.length - 1].trim()}`;\n    }\n    return listParts[0].trim();\n}\n/**\n * The document's computed CSS styles\n */\nlet documentStyles = undefined;\nlet documentThemeLinkTag = null;\n/**\n * Stores the state of theme loading\n */\nlet themeDidLoad;\nlet themeHasLoaded = false;\nlet themeWasRequested = false;\nconst themeLoaded = new Promise((res) => {\n    themeDidLoad = () => {\n        themeHasLoaded = true;\n        res();\n    };\n});\n/**\n * Check if we are client-side\n */\nconst isClient = typeof window !== 'undefined' && typeof fetch !== 'undefined';\ndocumentStyles = isClient ? getComputedStyle(document.documentElement) : undefined;\n/**\n * The FormKit icon Registry - a global record of loaded icons.\n * @public\n */\nconst iconRegistry = {};\n/**\n * A collection of existing icon requests to avoid duplicate fetching\n */\nconst iconRequests = {};\n/**\n * Creates the theme plugin based on a given theme name\n * @param theme - The name or id of the theme to apply\n * @param icons - Icons you want to add to the global icon registry\n * @param iconLoader - A function that handles loading an icon when it is not found in the registry\n * @public\n */\nfunction createThemePlugin(theme, icons, iconLoaderUrl, iconLoader) {\n    if (icons) {\n        // add any user-provided icons to the registry\n        Object.assign(iconRegistry, icons);\n    }\n    // if we have a theme declared, request it\n    if (isClient &&\n        !themeWasRequested &&\n        (documentStyles === null || documentStyles === void 0 ? void 0 : documentStyles.getPropertyValue('--formkit-theme'))) {\n        // we have the theme loaded locally\n        themeDidLoad();\n        themeWasRequested = true;\n    }\n    else if (theme &&\n        !themeWasRequested &&\n        isClient) {\n        // we have the theme name but need to request it remotely\n        loadTheme(theme);\n    }\n    else if (!themeWasRequested &&\n        isClient) {\n        // we don't have a discoverable theme, so don't wait for it\n        themeDidLoad();\n    }\n    const themePlugin = function themePlugin(node) {\n        var _a, _b;\n        // register the icon handler, and override with local prop value if it exists\n        node.addProps(['iconLoader', 'iconLoaderUrl']);\n        node.props.iconHandler = createIconHandler(((_a = node.props) === null || _a === void 0 ? void 0 : _a.iconLoader) ? node.props.iconLoader : iconLoader, ((_b = node.props) === null || _b === void 0 ? void 0 : _b.iconLoaderUrl) ? node.props.iconLoaderUrl : iconLoaderUrl);\n        loadIconPropIcons(node, node.props.iconHandler);\n        node.on('created', () => {\n            var _a;\n            // set up the `-icon` click handlers\n            if ((_a = node === null || node === void 0 ? void 0 : node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n                node.context.handlers.iconClick = (sectionKey) => {\n                    const clickHandlerProp = `on${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}IconClick`;\n                    const handlerFunction = node.props[clickHandlerProp];\n                    if (handlerFunction && typeof handlerFunction === 'function') {\n                        return (e) => {\n                            return handlerFunction(node, e);\n                        };\n                    }\n                    return undefined;\n                };\n            }\n        });\n    };\n    themePlugin.iconHandler = createIconHandler(iconLoader, iconLoaderUrl);\n    return themePlugin;\n}\n/**\n * Loads a FormKit theme\n */\nfunction loadTheme(theme) {\n    if (!theme ||\n        !isClient ||\n        typeof getComputedStyle !== 'function') {\n        // if we're not client-side then bail\n        return;\n    }\n    // since we're client-side, flag that we've requested the theme\n    themeWasRequested = true;\n    documentThemeLinkTag = document.getElementById('formkit-theme');\n    // retrieve document styles on plugin creation when the window object exists\n    if (theme &&\n        // if we have a window object\n        isClient &&\n        // we don't have an existing theme OR the theme being set up is different\n        ((!(documentStyles === null || documentStyles === void 0 ? void 0 : documentStyles.getPropertyValue('--formkit-theme')) &&\n            !documentThemeLinkTag) || ((documentThemeLinkTag === null || documentThemeLinkTag === void 0 ? void 0 : documentThemeLinkTag.getAttribute('data-theme')) &&\n            (documentThemeLinkTag === null || documentThemeLinkTag === void 0 ? void 0 : documentThemeLinkTag.getAttribute('data-theme')) !== theme))) {\n        // if for some reason we didn't overwrite the __FKV__ token during publish\n        // then use the `latest` tag for CDN fetching. (this applies to local dev as well)\n        const formkitVersion = FORMKIT_VERSION.startsWith('__') ? 'latest' : FORMKIT_VERSION;\n        const themeUrl = `https://cdn.jsdelivr.net/npm/@formkit/themes@${formkitVersion}/dist/${theme}/theme.css`;\n        const link = document.createElement('link');\n        link.type = 'text/css';\n        link.rel = 'stylesheet';\n        link.id = 'formkit-theme';\n        link.setAttribute('data-theme', theme);\n        link.onload = () => {\n            documentStyles = getComputedStyle(document.documentElement); // grab new variables from theme\n            themeDidLoad();\n        };\n        document.head.appendChild(link);\n        link.href = themeUrl;\n        // if we had an existing theme being loaded, remove it.\n        if (documentThemeLinkTag) {\n            documentThemeLinkTag.remove();\n        }\n    }\n}\n/**\n * Returns a function responsible for loading an icon by name\n * @param iconLoader - a function for loading an icon when it's not found in the iconRegistry\n * @public\n */\nfunction createIconHandler(iconLoader, iconLoaderUrl) {\n    return (iconName) => {\n        if (typeof iconName === 'boolean') {\n            return; // do nothing if we're dealing with a boolean\n        }\n        // if we're dealing with an inline SVG, just use it as-is\n        if (iconName.startsWith('<svg')) {\n            return iconName;\n        }\n        if (typeof iconName !== 'string')\n            return; // bail if we got something that wasn't a boolean or string\n        // check if we've already loaded the icon before\n        const icon = iconRegistry[iconName];\n        // is this a default icon that should only load from a stylesheet?\n        const isDefault = iconName.startsWith('default:');\n        iconName = isDefault ? iconName.split(':')[1] : iconName;\n        let loadedIcon = undefined;\n        if (icon || iconName in iconRegistry) {\n            return icon;\n        }\n        else if (!iconRequests[iconName]) {\n            loadedIcon = getIconFromStylesheet(iconName);\n            loadedIcon = isClient && typeof loadedIcon === 'undefined' ? Promise.resolve(loadedIcon) : loadedIcon;\n            if (loadedIcon instanceof Promise) {\n                iconRequests[iconName] = loadedIcon.then((iconValue) => {\n                    if (!iconValue && typeof iconName === 'string' && !isDefault) {\n                        return loadedIcon = typeof iconLoader === 'function' ? iconLoader(iconName) : getRemoteIcon(iconName, iconLoaderUrl);\n                    }\n                    return iconValue;\n                }).then((finalIcon) => {\n                    if (typeof iconName === 'string') {\n                        iconRegistry[isDefault ? `default:${iconName}` : iconName] = finalIcon;\n                    }\n                    return finalIcon;\n                });\n            }\n            else if (typeof loadedIcon === 'string') {\n                iconRegistry[isDefault ? `default:${iconName}` : iconName] = loadedIcon;\n                return loadedIcon;\n            }\n        }\n        return iconRequests[iconName];\n    };\n}\nfunction getIconFromStylesheet(iconName) {\n    if (!isClient)\n        return;\n    if (themeHasLoaded) {\n        return loadStylesheetIcon(iconName);\n    }\n    else {\n        return themeLoaded.then(() => {\n            return loadStylesheetIcon(iconName);\n        });\n    }\n}\nfunction loadStylesheetIcon(iconName) {\n    const cssVarIcon = documentStyles === null || documentStyles === void 0 ? void 0 : documentStyles.getPropertyValue(`--fk-icon-${iconName}`);\n    if (cssVarIcon) {\n        // if we have a matching icon in the CSS properties, then decode it\n        const icon = atob(cssVarIcon);\n        if (icon.startsWith('<svg')) {\n            iconRegistry[iconName] = icon;\n            return icon;\n        }\n    }\n    return undefined;\n}\n/**\n * Attempts to fetch a remote icon from the FormKit CDN\n * @param iconName - The string name of the icon\n * @public\n */\nfunction getRemoteIcon(iconName, iconLoaderUrl) {\n    const formkitVersion = FORMKIT_VERSION.startsWith('__') ? 'latest' : FORMKIT_VERSION;\n    const fetchUrl = typeof iconLoaderUrl === 'function' ? iconLoaderUrl(iconName) : `https://cdn.jsdelivr.net/npm/@formkit/icons@${formkitVersion}/dist/icons/${iconName}.svg`;\n    if (!isClient)\n        return undefined;\n    return fetch(`${fetchUrl}`)\n        .then(async (r) => {\n        const icon = await r.text();\n        if (icon.startsWith('<svg')) {\n            return icon;\n        }\n        return undefined;\n    })\n        .catch(e => {\n        console.error(e);\n        return undefined;\n    });\n}\n/**\n * Loads icons for the matching `-icon` props on a given node\n */\nfunction loadIconPropIcons(node, iconHandler) {\n    const iconRegex = /^[a-zA-Z-]+(?:-icon|Icon)$/;\n    const iconProps = Object.keys(node.props).filter((prop) => {\n        return iconRegex.test(prop);\n    });\n    iconProps.forEach((sectionKey) => {\n        return loadPropIcon(node, iconHandler, sectionKey);\n    });\n}\n/**\n * Loads an icon from an icon-prop declaration eg. suffix-icon=\"settings\"\n */\nfunction loadPropIcon(node, iconHandler, sectionKey) {\n    const iconName = node.props[sectionKey];\n    const loadedIcon = iconHandler(iconName);\n    const rawIconProp = `_raw${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}`;\n    const clickHandlerProp = `on${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}Click`;\n    node.addProps([rawIconProp, clickHandlerProp]);\n    // listen for changes to the icon prop\n    node.on(`prop:${sectionKey}`, reloadIcon);\n    if (loadedIcon instanceof Promise) {\n        return loadedIcon.then((svg) => {\n            node.props[rawIconProp] = svg;\n        });\n    }\n    else {\n        node.props[rawIconProp] = loadedIcon;\n    }\n    return;\n}\n/**\n * reloads an icon when the prop value changes\n */\nfunction reloadIcon(event) {\n    var _a;\n    const node = event.origin;\n    const iconName = event.payload;\n    const iconHandler = (_a = node === null || node === void 0 ? void 0 : node.props) === null || _a === void 0 ? void 0 : _a.iconHandler;\n    const sectionKey = event.name.split(':')[1];\n    const rawIconProp = `_raw${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}`;\n    if (iconHandler && typeof iconHandler === 'function') {\n        const loadedIcon = iconHandler(iconName);\n        if (loadedIcon instanceof Promise) {\n            return loadedIcon.then((svg) => {\n                node.props[rawIconProp] = svg;\n            });\n        }\n        else {\n            node.props[rawIconProp] = loadedIcon;\n        }\n    }\n}\n\nexport { createIconHandler, createThemePlugin, generateClasses, iconRegistry };\n", "import { errorHandler, warningHandler } from '@formkit/core';\n\nlet registered = false;\n/**\n * Catalog of the error message codes in FormKit.\n * @public\n */\nconst errors = {\n    /**\n     * FormKit errors:\n     */\n    100: ({ data: node }) => `Only groups, lists, and forms can have children (${node.name}).`,\n    101: ({ data: node }) => `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,\n    102: ({ data: [node, property], }) => `You cannot directly assign node.${property} (${node.name})`,\n    103: ({ data: [operator] }) => `Schema expressions cannot start with an operator (${operator})`,\n    104: ({ data: [operator, expression] }) => `Schema expressions cannot end with an operator (${operator} in \"${expression}\")`,\n    105: ({ data: expression }) => `Invalid schema expression: ${expression}`,\n    106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,\n    107: ({ data: [node, value] }) => `Cannot set ${node.name} to non object value: ${value}`,\n    108: ({ data: [node, value] }) => `Cannot set ${node.name} to non array value: ${value}`,\n    /**\n     * FormKit vue errors:\n     */\n    600: ({ data: node }) => `Unknown input type${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} (\"${node.name}\")`,\n    601: ({ data: node }) => `Input definition${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} is missing a schema or component property (${node.name}).`,\n};\n/**\n * Catalog of the warning message codes in FormKit.\n * @public\n */\nconst warnings = {\n    /**\n     * Core warnings:\n     */\n    150: ({ data: fn }) => `Schema function \"${fn}()\" is not a valid function.`,\n    151: ({ data: id }) => `No form element with id: ${id}`,\n    152: ({ data: id }) => `No input element with id: ${id}`,\n    /**\n     * Input specific warnings:\n     */\n    350: ({ data: node }) => `Invalid options prop for radio input (${node.name}). See https://formkit.com/inputs/radio`,\n    /**\n     * Vue warnings:\n     */\n    650: 'Schema \"$get()\" must use the id of an input to access.',\n    651: ({ data: id }) => `Cannot setErrors() on \"${id}\" because no such id exists.`,\n    652: ({ data: id }) => `Cannot clearErrors() on \"${id}\" because no such id exists.`,\n    /**\n     * Deprecation warnings:\n     */\n    800: ({ data: name }) => `${name} is deprecated.`,\n};\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeErrors = (error, next) => {\n    if (error.code in errors) {\n        const err = errors[error.code];\n        error.message = typeof err === 'function' ? err(error) : err;\n    }\n    return next(error);\n};\nif (!registered)\n    errorHandler(decodeErrors);\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeWarnings = (warning, next) => {\n    if (warning.code in warnings) {\n        const warn = warnings[warning.code];\n        warning.message = typeof warn === 'function' ? warn(warning) : warn;\n    }\n    return next(warning);\n};\nif (!registered)\n    warningHandler(decodeWarnings);\nregistered = true;\n\nexport { errors, warnings };\n", "import { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, clearErrors, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';\nexport { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { defineComponent, getCurrentInstance, watch, watchEffect, reactive, ref, createTextVNode, resolveComponent, h, isRef, isReactive, toRaw, inject, computed, provide, toRef, onUnmounted, markRaw, nextTick, triggerRef } from 'vue';\nimport { has, isPojo, cloneAny, extend, camel, kebab, nodeProps, only, except, slugify, isObject, empty, eq, undefine } from '@formkit/utils';\nimport { createSection, useSchema, createLibraryPlugin, inputs } from '@formkit/inputs';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nimport { createThemePlugin, createIconHandler } from '@formkit/themes';\nimport { createObserver } from '@formkit/observer';\nimport '@formkit/dev';\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo = {};\n/**\n * This symbol represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey;\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance symbol. For example data from: for-loop instances and slot data.\n */\nconst instanceScopes = new Map();\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__';\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(token, data) {\n    const value = ref(null);\n    if (token === 'get') {\n        const nodeRefs = {};\n        value.value = get$1.bind(null, nodeRefs);\n        return value;\n    }\n    const path = token.split('.');\n    watchEffect(() => (value.value = getValue(data, path)));\n    return value;\n}\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(set, path) {\n    if (Array.isArray(set)) {\n        for (const subset of set) {\n            const value = subset !== false && getValue(subset, path);\n            if (value !== undefined)\n                return value;\n        }\n        return undefined;\n    }\n    let foundValue = undefined;\n    path.reduce((obj, segment, i, arr) => {\n        if (typeof obj !== 'object') {\n            foundValue = undefined;\n            return arr.splice(1); // Forces an exit\n        }\n        const currentValue = obj[segment];\n        if (i === path.length - 1 && currentValue !== undefined) {\n            foundValue = currentValue;\n        }\n        return obj[segment];\n    }, set);\n    return foundValue;\n}\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get$1(nodeRefs, id) {\n    if (typeof id !== 'string')\n        return warn(650);\n    if (!(id in nodeRefs))\n        nodeRefs[id] = ref(undefined);\n    if (nodeRefs[id].value === undefined) {\n        nodeRefs[id].value = null;\n        const root = getNode(id);\n        if (root)\n            nodeRefs[id].value = root.context;\n        watchRegistry(id, ({ payload: node }) => {\n            nodeRefs[id].value = isNode(node) ? node.context : node;\n        });\n    }\n    return nodeRefs[id].value;\n}\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(library, schema) {\n    /**\n     * Given an if/then/else schema node, pre-compile the node and return the\n     * artifacts for the render function.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     */\n    function parseCondition(library, node) {\n        const condition = provider(compile(node.if), { if: true });\n        const children = createElements(library, node.then);\n        const alternate = node.else ? createElements(library, node.else) : null;\n        return [condition, children, alternate];\n    }\n    /**\n     * Parses a conditional if/then/else attribute statement.\n     * @param data - The data object\n     * @param attr - The attribute\n     * @param _default - The default value\n     * @returns\n     */\n    function parseConditionAttr(attr, _default) {\n        var _a, _b;\n        const condition = provider(compile(attr.if));\n        let b = () => _default;\n        let a = () => _default;\n        if (typeof attr.then === 'object') {\n            a = parseAttrs(attr.then, undefined);\n        }\n        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {\n            a = provider(compile(attr.then));\n        }\n        else {\n            a = () => attr.then;\n        }\n        if (has(attr, 'else')) {\n            if (typeof attr.else === 'object') {\n                b = parseAttrs(attr.else);\n            }\n            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {\n                b = provider(compile(attr.else));\n            }\n            else {\n                b = () => attr.else;\n            }\n        }\n        return () => (condition() ? a() : b());\n    }\n    /**\n     * Parse attributes for dynamic content.\n     * @param attrs - Object of attributes\n     * @returns\n     */\n    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n        const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n        const staticAttrs = {};\n        const setters = [\n            (attrs) => {\n                const bound = boundAttrs();\n                for (const attr in bound) {\n                    if (!explicitAttrs.has(attr)) {\n                        attrs[attr] = bound[attr];\n                    }\n                }\n            },\n        ];\n        if (unparsedAttrs) {\n            if (isConditional(unparsedAttrs)) {\n                // This is a root conditional object that must produce an object of\n                // attributes.\n                const condition = parseConditionAttr(unparsedAttrs, _default);\n                return condition;\n            }\n            // Some attributes are explicitly bound, we need to parse those ones\n            // using the compiler and create a dynamic \"setter\".\n            for (let attr in unparsedAttrs) {\n                const value = unparsedAttrs[attr];\n                let getValue;\n                const isStr = typeof value === 'string';\n                if (attr.startsWith(raw)) {\n                    // attributes prefixed with __raw__ should not be parsed\n                    attr = attr.substring(7);\n                    getValue = () => value;\n                }\n                else if (isStr &&\n                    value.startsWith('$') &&\n                    value.length > 1 &&\n                    !(value.startsWith('$reset') && isClassProp.test(attr))) {\n                    // Most attribute values starting with $ should be compiled\n                    // -class attributes starting with `$reset` should not be compiled\n                    getValue = provider(compile(value));\n                }\n                else if (typeof value === 'object' && isConditional(value)) {\n                    // Conditional attrs require further processing\n                    getValue = parseConditionAttr(value, undefined);\n                }\n                else if (typeof value === 'object' && isPojo(value)) {\n                    // Sub-parse pojos\n                    getValue = parseAttrs(value);\n                }\n                else {\n                    // In all other cases, the value is static\n                    getValue = () => value;\n                    staticAttrs[attr] = value;\n                }\n                setters.push((attrs) => {\n                    attrs[attr] = getValue();\n                });\n            }\n        }\n        return () => {\n            const attrs = {};\n            setters.forEach((setter) => setter(attrs));\n            return attrs;\n        };\n    }\n    /**\n     * Given a single schema node, parse it and extract the value.\n     * @param data - A state object provided to each node\n     * @param node - The schema node being parsed\n     * @returns\n     */\n    function parseNode(library, _node) {\n        let element = null;\n        let attrs = () => null;\n        let condition = false;\n        let children = null;\n        let alternate = null;\n        let iterator = null;\n        let resolve = false;\n        const node = sugar(_node);\n        if (isDOM(node)) {\n            // This is an actual HTML DOM element\n            element = node.$el;\n            attrs =\n                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;\n        }\n        else if (isComponent$1(node)) {\n            // This is a Vue Component\n            if (typeof node.$cmp === 'string') {\n                if (has(library, node.$cmp)) {\n                    element = library[node.$cmp];\n                }\n                else {\n                    element = node.$cmp;\n                    resolve = true;\n                }\n            }\n            else {\n                // in this case it must be an actual component\n                element = node.$cmp;\n            }\n            attrs = parseAttrs(node.props, node.bind);\n        }\n        else if (isConditional(node)) {\n            [condition, children, alternate] = parseCondition(library, node);\n        }\n        // This is the same as a \"v-if\" statement \u2014 not an if/else statement\n        if (!isConditional(node) && 'if' in node) {\n            condition = provider(compile(node.if));\n        }\n        else if (!isConditional(node) && element === null) {\n            // In this odd case our element is actually a partial and\n            // we only want to render the children.\n            condition = () => true;\n        }\n        // Compile children down to a function\n        if ('children' in node && node.children) {\n            if (typeof node.children === 'string') {\n                // We are dealing with a raw string value\n                if (node.children.startsWith('$slots.')) {\n                    // this is a lone text node, turn it into a slot\n                    element = element === 'text' ? 'slot' : element;\n                    children = provider(compile(node.children));\n                }\n                else if (node.children.startsWith('$') && node.children.length > 1) {\n                    const value = provider(compile(node.children));\n                    children = () => String(value());\n                }\n                else {\n                    children = () => String(node.children);\n                }\n            }\n            else if (Array.isArray(node.children)) {\n                // We are dealing with node sub-children\n                children = createElements(library, node.children);\n            }\n            else {\n                // This is a conditional if/else clause\n                const [childCondition, c, a] = parseCondition(library, node.children);\n                children = (iterationData) => childCondition && childCondition()\n                    ? c && c(iterationData)\n                    : a && a(iterationData);\n            }\n        }\n        if (isComponent$1(node)) {\n            if (children) {\n                // Children of components need to be provided as an object of slots\n                // so we provide an object with the default slot provided as children.\n                // We also create a new scope for this default slot, and then on each\n                // render pass the scoped slot props to the scope.\n                const produceChildren = children;\n                children = (iterationData) => {\n                    return {\n                        default(slotData, key) {\n                            var _a, _b, _c, _d;\n                            // We need to switch the current instance key back to the one that\n                            // originally called this component's render function.\n                            const currentKey = instanceKey;\n                            if (key)\n                                instanceKey = key;\n                            if (slotData)\n                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);\n                            if (iterationData)\n                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);\n                            const c = produceChildren(iterationData);\n                            // Ensure our instance key never changed during runtime\n                            if (slotData)\n                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();\n                            if (iterationData)\n                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();\n                            instanceKey = currentKey;\n                            return c;\n                        },\n                    };\n                };\n                children.slot = true;\n            }\n            else {\n                // If we dont have any children, we still need to provide an object\n                // instead of an empty array (which raises a warning in vue)\n                children = () => ({});\n            }\n        }\n        // Compile the for loop down\n        if ('for' in node && node.for) {\n            const values = node.for.length === 3 ? node.for[2] : node.for[1];\n            const getValues = typeof values === 'string' && values.startsWith('$')\n                ? provider(compile(values))\n                : () => values;\n            iterator = [\n                getValues,\n                node.for[0],\n                node.for.length === 3 ? String(node.for[1]) : null,\n            ];\n        }\n        return [condition, element, attrs, children, alternate, iterator, resolve];\n    }\n    /**\n     * Given a particular function that produces children, ensure that the second\n     * argument of all these slots is the original instance key being used to\n     * render the slots.\n     * @param children - The children() function that will produce slots\n     */\n    function createSlots(children, iterationData) {\n        const slots = children(iterationData);\n        const currentKey = instanceKey;\n        return Object.keys(slots).reduce((allSlots, slotName) => {\n            const slotFn = slots && slots[slotName];\n            allSlots[slotName] = (data) => {\n                return (slotFn && slotFn(data, currentKey)) || null;\n            };\n            return allSlots;\n        }, {});\n    }\n    /**\n     * Creates an element\n     * @param data - The context data available to the node\n     * @param node - The schema node to render\n     * @returns\n     */\n    function createElement(library, node) {\n        // Parses the schema node into pertinent parts\n        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);\n        // This is a sub-render function (called within a render function). It must\n        // only use pre-compiled features, and be organized in the most efficient\n        // manner possible.\n        let createNodes = ((iterationData) => {\n            if (condition && element === null && children) {\n                // Handle conditional if/then statements\n                return condition()\n                    ? children(iterationData)\n                    : alternate && alternate(iterationData);\n            }\n            if (element && (!condition || condition())) {\n                // handle text nodes\n                if (element === 'text' && children) {\n                    return createTextVNode(String(children()));\n                }\n                // Handle lone slots\n                if (element === 'slot' && children)\n                    return children(iterationData);\n                // Handle resolving components\n                const el = resolve ? resolveComponent(element) : element;\n                // If we are rendering slots as children, ensure their instanceKey is properly added\n                const slots = (children === null || children === void 0 ? void 0 : children.slot)\n                    ? createSlots(children, iterationData)\n                    : null;\n                // Handle dom elements and components\n                return h(el, attrs(), (slots || (children ? children(iterationData) : [])));\n            }\n            return typeof alternate === 'function'\n                ? alternate(iterationData)\n                : alternate;\n        });\n        if (iterator) {\n            const repeatedNode = createNodes;\n            const [getValues, valueName, keyName] = iterator;\n            createNodes = (() => {\n                const _v = getValues();\n                const values = !isNaN(_v)\n                    ? Array(Number(_v))\n                        .fill(0)\n                        .map((_, i) => i)\n                    : _v;\n                const fragment = [];\n                if (typeof values !== 'object')\n                    return null;\n                const instanceScope = instanceScopes.get(instanceKey) || [];\n                for (const key in values) {\n                    if (Array.isArray(values) && key === 'length')\n                        continue; // Fix #299\n                    const iterationData = Object.defineProperty({\n                        ...instanceScope.reduce((previousIterationData, scopedData) => {\n                            if (previousIterationData.__idata) {\n                                return { ...previousIterationData, ...scopedData };\n                            }\n                            return scopedData;\n                        }, {}),\n                        [valueName]: values[key],\n                        ...(keyName !== null ? { [keyName]: key } : {}),\n                    }, '__idata', { enumerable: false, value: true });\n                    instanceScope.unshift(iterationData);\n                    fragment.push(repeatedNode.bind(null, iterationData)());\n                    instanceScope.shift();\n                }\n                return fragment;\n            });\n        }\n        return createNodes;\n    }\n    /**\n     * Given a schema, parse it and return the resulting renderable nodes.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     * @returns\n     */\n    function createElements(library, schema) {\n        if (Array.isArray(schema)) {\n            const els = schema.map(createElement.bind(null, library));\n            return (iterationData) => els.map((element) => element(iterationData));\n        }\n        // Single node to render\n        const element = createElement(library, schema);\n        return (iterationData) => element(iterationData);\n    }\n    /**\n     * Data providers produced as a result of the compiler.\n     */\n    const providers = [];\n    /**\n     * Append the requisite compiler provider and return the compiled function.\n     * @param compiled - A compiled function\n     * @returns\n     */\n    function provider(compiled, hints = {}) {\n        const compiledFns = {};\n        providers.push((callback, key) => {\n            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));\n        });\n        return () => compiledFns[instanceKey]();\n    }\n    /**\n     * Creates a new instance of a given schema \u2014 this either comes from a\n     * memoized copy of the parsed schema or a freshly parsed version. An symbol\n     * instance key, and dataProvider functions are passed in.\n     * @param providerCallback - A function that is called for each required provider\n     * @param key - a symbol representing the current instance\n     */\n    return function createInstance(providerCallback, key) {\n        const memoKey = JSON.stringify(schema);\n        const [render, compiledProviders] = has(memo, memoKey)\n            ? memo[memoKey]\n            : [createElements(library, schema), providers];\n        memo[memoKey] = [render, compiledProviders];\n        compiledProviders.forEach((compiledProvider) => {\n            compiledProvider(providerCallback, key);\n        });\n        return () => {\n            instanceKey = key;\n            return render();\n        };\n    };\n}\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token, defaultValue) {\n    const scopedData = instanceScopes.get(instanceKey) || [];\n    let scopedValue = undefined;\n    if (scopedData.length) {\n        scopedValue = getValue(scopedData, token.split('.'));\n    }\n    return scopedValue === undefined ? defaultValue : scopedValue;\n}\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data, key) {\n    return new Proxy(data, {\n        get(...args) {\n            let data = undefined;\n            const property = args[1];\n            if (typeof property === 'string') {\n                const prevKey = instanceKey;\n                instanceKey = key;\n                data = useScope(property, undefined);\n                instanceKey = prevKey;\n            }\n            return data !== undefined ? data : Reflect.get(...args);\n        },\n    });\n}\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(instanceCreator, data, instanceKey) {\n    return instanceCreator((requirements, hints = {}) => {\n        return requirements.reduce((tokens, token) => {\n            if (token.startsWith('slots.')) {\n                const slot = token.substring(6);\n                const hasSlot = data.slots && has(data.slots, slot);\n                if (hints.if) {\n                    // If statement \u2014 dont render the slot, check if it exists\n                    tokens[token] = () => hasSlot;\n                }\n                else if (data.slots && hasSlot) {\n                    // Render the slot with current scope data\n                    const scopedData = slotData(data, instanceKey);\n                    tokens[token] = () => data.slots[slot](scopedData);\n                    return tokens;\n                }\n            }\n            const value = getRef(token, data);\n            tokens[token] = () => useScope(token, value.value);\n            return tokens;\n        }, {});\n    }, instanceKey);\n}\nlet i = 0;\n/**\n * The FormKitSchema vue component:\n * @public\n */\nconst FormKitSchema = defineComponent({\n    name: 'FormKitSchema',\n    props: {\n        schema: {\n            type: [Array, Object],\n            required: true,\n        },\n        data: {\n            type: Object,\n            default: () => ({}),\n        },\n        library: {\n            type: Object,\n            default: () => ({}),\n        },\n    },\n    setup(props, context) {\n        const instance = getCurrentInstance();\n        let instanceKey = Symbol(String(i++));\n        instanceScopes.set(instanceKey, []);\n        let provider = parseSchema(props.library, props.schema);\n        let render;\n        let data;\n        // Re-parse the schema if it changes:\n        watch(() => props.schema, (newSchema, oldSchema) => {\n            var _a;\n            instanceKey = Symbol(String(i++));\n            provider = parseSchema(props.library, props.schema);\n            render = createRenderFn(provider, data, instanceKey);\n            if (newSchema === oldSchema) {\n                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();\n            }\n        }, { deep: true });\n        // Watch the data object explicitly\n        watchEffect(() => {\n            data = Object.assign(reactive(props.data), {\n                slots: context.slots,\n            });\n            render = createRenderFn(provider, data, instanceKey);\n        });\n        return () => render();\n    },\n});\n\n/**\n * All the explicit FormKit props.\n */\nconst nativeProps = {\n    config: {\n        type: Object,\n        default: {},\n    },\n    classes: {\n        type: Object,\n        required: false,\n    },\n    delay: {\n        type: Number,\n        required: false,\n    },\n    errors: {\n        type: Array,\n        default: [],\n    },\n    inputErrors: {\n        type: Object,\n        default: () => ({}),\n    },\n    index: {\n        type: Number,\n        required: false,\n    },\n    id: {\n        type: String,\n        required: false,\n    },\n    modelValue: {\n        required: false,\n    },\n    name: {\n        type: String,\n        required: false,\n    },\n    parent: {\n        type: Object,\n        required: false,\n    },\n    plugins: {\n        type: Array,\n        default: [],\n    },\n    sectionsSchema: {\n        type: Object,\n        default: {},\n    },\n    type: {\n        type: [String, Object],\n        default: 'text',\n    },\n    validation: {\n        type: [String, Array],\n        required: false,\n    },\n    validationMessages: {\n        type: Object,\n        required: false,\n    },\n    validationRules: {\n        type: Object,\n        required: false,\n    },\n    validationLabel: {\n        type: [String, Function],\n        required: false,\n    },\n};\n/**\n * The FormKit props object.\n * @internal\n */\nconst props = nativeProps;\n\n/**\n * The symbol that represents the formkit parent injection value.\n * @public\n */\nconst parentSymbol = Symbol('FormKitParent');\n/**\n * The root FormKit component.\n * @public\n */\nconst FormKit = defineComponent({\n    props,\n    emits: {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        input: (_value, _node) => true,\n        inputRaw: (_value, _node) => true,\n        'update:modelValue': (_value) => true,\n        node: (node) => !!node,\n        submit: (_data, _node) => true,\n        submitRaw: (_event, _node) => true,\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n    },\n    inheritAttrs: false,\n    setup(props, context) {\n        const node = useInput(props, context);\n        if (!node.props.definition)\n            error(600, node);\n        if (node.props.definition.component) {\n            return () => {\n                var _a;\n                return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {\n                    context: node.context,\n                }, { ...context.slots });\n            };\n        }\n        const schema = ref([]);\n        const generateSchema = () => {\n            var _a, _b;\n            const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;\n            if (!schemaDefinition)\n                error(601, node);\n            schema.value =\n                typeof schemaDefinition === 'function'\n                    ? schemaDefinition({ ...props.sectionsSchema })\n                    : schemaDefinition;\n        };\n        generateSchema();\n        // If someone emits the schema event, we re-generate the schema\n        node.on('schema', generateSchema);\n        context.emit('node', node);\n        const library = node.props.definition.library;\n        // Expose the FormKitNode to template refs.\n        context.expose({ node });\n        return () => h(FormKitSchema, { schema: schema.value, data: node.context, library }, { ...context.slots });\n    },\n});\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n */\nfunction createPlugin(app, options) {\n    app\n        .component(options.alias || 'FormKit', FormKit)\n        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);\n    return {\n        get: getNode,\n        setLocale: (locale) => {\n            var _a;\n            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {\n                options.config.rootConfig.locale = locale;\n            }\n        },\n        clearErrors,\n        setErrors,\n        submit: submitForm,\n        reset,\n    };\n}\n/**\n * The symbol key for accessing the FormKit node options.\n * @public\n */\nconst optionsSymbol = Symbol.for('FormKitOptions');\n/**\n * The symbol key for accessing FormKit root configuration.\n * @public\n */\nconst configSymbol = Symbol.for('FormKitConfig');\n/**\n * Create the FormKit plugin.\n * @public\n */\nconst plugin = {\n    install(app, _options) {\n        /**\n         * Extend the default configuration options.\n         */\n        const options = Object.assign({\n            alias: 'FormKit',\n            schemaAlias: 'FormKitSchema',\n        }, typeof _options === 'function' ? _options() : _options);\n        /**\n         * The root configuration options.\n         */\n        const rootConfig = createConfig(options.config || {});\n        /**\n         * We dont want to explicitly provide any \"config\" options, only a root\n         * config option \u2014 so here we override the existing config options.\n         */\n        options.config = { rootConfig };\n        /**\n         * Register the global $formkit plugin property.\n         */\n        app.config.globalProperties.$formkit = createPlugin(app, options);\n        /**\n         * Provide the config to the application for injection.\n         */\n        app.provide(optionsSymbol, options);\n        /**\n         * Provide the root config to the application.\n         */\n        app.provide(configSymbol, rootConfig);\n    },\n};\n\n/**\n * Indicates that the path that was requested is no longer valid in the object.\n */\nconst invalidGet = Symbol();\n/**\n *\n * @param obj - An object to observe at depth\n * @param callback - A callback that\n * @public\n */\nfunction watchVerbose(obj, callback) {\n    const watchers = {};\n    const applyWatch = (paths) => {\n        // Watch each property\n        for (const path of paths) {\n            // Stops pre-existing watchers at a given location to prevent dupes:\n            if (path.__str in watchers)\n                watchers[path.__str]();\n            watchers[path.__str] = watch(touch.bind(null, obj, path), dispatcher.bind(null, path), { deep: false });\n        }\n    };\n    /**\n     * Clear any watchers deeper than this path.\n     * @param path - The path to start from\n     */\n    const clearWatch = (path) => {\n        if (!path.length)\n            return;\n        for (const key in watchers) {\n            if (`${key}`.startsWith(`${path.__str}.`)) {\n                watchers[key]();\n                delete watchers[key];\n            }\n        }\n    };\n    const dispatcher = createDispatcher(obj, callback, applyWatch, clearWatch);\n    applyWatch(getPaths(obj));\n}\n/**\n * This function synchronously dispatches to the watch callbacks. It uses the\n * knowledge that the getPath function is a depth-first-search thus lower\n * specificity (lower tree nodes) will always have their watchers called first.\n * If a lower specificity watcher is triggered we want to ignore the higher\n * specificity watcher.\n * @param obj - The object to dispatch\n * @param callback - The callback function to emit\n * @param applyWatch - A way to apply watchers to update objects\n * @returns\n */\nfunction createDispatcher(obj, callback, applyWatch, clearChildWatches) {\n    // let dispatchedPaths: Record<string, ObjectPath> = {}\n    // let clear: Promise<void> | null = null\n    return (path) => {\n        const value = get(obj, path);\n        if (value === invalidGet)\n            return;\n        if (path.__deep)\n            clearChildWatches(path);\n        if (typeof value === 'object')\n            applyWatch(getPaths(value, [path], ...path));\n        callback(path, value, obj);\n    };\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes, if the value at\n * the given path is an object, we flatten it to just its keys since we will\n * already be tracking sub properties independently.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction touch(obj, path) {\n    const value = get(obj, path);\n    return value && typeof value === 'object' ? Object.keys(value) : value;\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction get(obj, path) {\n    if (isRef(obj)) {\n        if (path.length === 0)\n            return obj.value;\n        obj = obj.value;\n    }\n    return path.reduce((value, segment) => {\n        if (value === invalidGet)\n            return value;\n        if (value === null || typeof value !== 'object') {\n            return invalidGet;\n        }\n        return value[segment];\n    }, obj);\n}\n/**\n * Recursively retrieves all enumerable property paths from the origination\n * object. For example:\n * ```js\n * const obj = {\n *   a: {\n *     b: 123\n *   },\n *   c: 567\n * }\n * const paths = getPaths(obj)\n * // [\n * //   ['a'],\n * //   ['a', 'b'],\n * //   ['c']\n * // ]\n * ```\n * @param obj - An object to retrieve paths for.\n * @param parents - An array of parent paths.\n * @returns\n * @internal\n */\nfunction getPaths(obj, paths = [], ...parents) {\n    if (obj === null)\n        return paths;\n    if (!parents.length) {\n        const path = Object.defineProperty([], '__str', {\n            value: '',\n        });\n        obj = isRef(obj) ? obj.value : obj;\n        if (obj && typeof obj === 'object') {\n            Object.defineProperty(path, '__deep', { value: true });\n            paths.push(path);\n        }\n        else {\n            return [path];\n        }\n    }\n    if (obj === null || typeof obj !== 'object')\n        return paths;\n    for (const key in obj) {\n        const path = parents.concat(key);\n        Object.defineProperty(path, '__str', { value: path.join('.') });\n        const value = obj[key];\n        if (isPojo(value) || Array.isArray(value)) {\n            paths.push(Object.defineProperty(path, '__deep', { value: true }));\n            paths = paths.concat(getPaths(value, [], ...path));\n        }\n        else {\n            paths.push(path);\n        }\n    }\n    return paths;\n}\n\n/**\n * Gets the raw underlying target object from a Vue Ref or Reactive object.\n * @param obj - Get the underlying target object, or no-op.\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction useRaw(obj) {\n    if (obj === null || typeof obj !== 'object')\n        return obj;\n    if (isReactive(obj)) {\n        obj = toRaw(obj);\n    }\n    else if (isRef(obj)) {\n        obj = (isReactive(obj.value) ? useRaw(obj.value) : obj.value);\n    }\n    return obj;\n}\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n    'help',\n    'label',\n    'ignore',\n    'disabled',\n    'preserve',\n    /^preserve(-e|E)rrors/,\n    /^[a-z]+(?:-visibility|Visibility)$/,\n    /^[a-zA-Z-]+(?:-class|Class)$/,\n    'prefixIcon',\n    'suffixIcon',\n    /^[a-zA-Z-]+(?:-icon|Icon)$/,\n];\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node, props) {\n    if (props.classes) {\n        Object.keys(props.classes).forEach((key) => {\n            if (typeof key === 'string') {\n                node.props[`_${key}Class`] = props.classes[key];\n                // We need to ensure Vue is aware that we want to actually observe the\n                // child values too, so we touch them here.\n                if (isObject(props.classes[key]) && key === 'inner')\n                    Object.values(props.classes[key]);\n            }\n        });\n    }\n}\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(props) {\n    if (!props)\n        return {};\n    const knownListeners = ['Submit', 'SubmitRaw'].reduce((listeners, listener) => {\n        const name = `on${listener}`;\n        if (name in props) {\n            if (typeof props[name] === 'function') {\n                listeners[name] = props[name];\n            }\n        }\n        return listeners;\n    }, {});\n    return knownListeners;\n}\n/**\n * A composable for creating a new FormKit node.\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" \u2014 which is really the attrs list.\n * @returns\n * @public\n */\nfunction useInput(props, context, options = {}) {\n    /**\n     * The configuration options, these are provided by either the plugin or by\n     * explicit props.\n     */\n    const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n    /**\n     * The current instance.\n     */\n    const instance = getCurrentInstance();\n    /**\n     * Extracts the listeners.\n     */\n    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);\n    /**\n     * Determines if the prop is v-modeled.\n     */\n    const isVModeled = props.modelValue !== undefined;\n    /**\n     * Determines if the object being passed as a v-model is reactive.\n     */\n    // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\n    /**\n     * Define the initial component\n     */\n    const value = props.modelValue !== undefined\n        ? props.modelValue\n        : cloneAny(context.attrs.value);\n    /**\n     * Creates the node's initial props from the context, props, and definition\n     * @returns\n     */\n    function createInitialProps() {\n        const initialProps = {\n            ...nodeProps(props),\n            ...listeners,\n        };\n        const attrs = except(nodeProps(context.attrs), pseudoProps);\n        initialProps.attrs = attrs;\n        const propValues = only(nodeProps(context.attrs), pseudoProps);\n        for (const propName in propValues) {\n            initialProps[camel(propName)] = propValues[propName];\n        }\n        const classesProps = { props: {} };\n        classesToNodeProps(classesProps, props);\n        Object.assign(initialProps, classesProps.props);\n        if (typeof initialProps.type !== 'string') {\n            initialProps.definition = initialProps.type;\n            delete initialProps.type;\n        }\n        return initialProps;\n    }\n    /**\n     * Create the FormKitNode.\n     */\n    const initialProps = createInitialProps();\n    /**\n     * The parent node.\n     */\n    const parent = initialProps.ignore\n        ? null\n        : props.parent || inject(parentSymbol, null);\n    const node = createNode(extend(config || {}, {\n        name: props.name || undefined,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins),\n        config: props.config,\n        props: initialProps,\n        index: props.index,\n    }, false, true));\n    /**\n     * If no definition has been assigned at this point \u2014 we're out!\n     */\n    if (!node.props.definition)\n        error(600, node);\n    /**\n     * All props that are bound \"late\" (after node creation) \u2014 are added to a set\n     * which is used to watch the context.attrs object.\n     */\n    const lateBoundProps = ref(new Set(node.props.definition.props || []));\n    /**\n     * Any additional props added at a \"later\" time should also be part of the\n     * late bound props.\n     */\n    node.on('added-props', ({ payload: lateProps }) => {\n        if (Array.isArray(lateProps))\n            lateProps.forEach((newProp) => lateBoundProps.value.add(newProp));\n    });\n    /**\n     * These prop names must be assigned.\n     */\n    const pseudoPropNames = computed(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n        if (typeof prop === 'string') {\n            names.push(camel(prop));\n            names.push(kebab(prop));\n        }\n        else {\n            names.push(prop);\n        }\n        return names;\n    }, []));\n    /* Splits Classes object into discrete props for each key */\n    watchEffect(() => classesToNodeProps(node, props));\n    /**\n     * The props object already has properties even if they start as \"undefined\"\n     * so we can loop over them and individual watchEffect to prevent responding\n     * inappropriately.\n     */\n    const passThrough = nodeProps(props);\n    for (const prop in passThrough) {\n        watch(() => props[prop], () => {\n            if (props[prop] !== undefined) {\n                node.props[prop] = props[prop];\n            }\n        });\n    }\n    /**\n     * Watch \"pseudoProp\" attributes explicitly.\n     */\n    const attributeWatchers = new Set();\n    const possibleProps = nodeProps(context.attrs);\n    watchEffect(() => {\n        watchAttributes(only(possibleProps, pseudoPropNames.value));\n    });\n    /**\n     * Defines attributes that should be used as props.\n     * @param attrProps - Attributes that should be used as props instead\n     */\n    function watchAttributes(attrProps) {\n        attributeWatchers.forEach((stop) => {\n            stop();\n            attributeWatchers.delete(stop);\n        });\n        for (const prop in attrProps) {\n            const camelName = camel(prop);\n            attributeWatchers.add(watch(() => context.attrs[prop], () => {\n                node.props[camelName] = context.attrs[prop];\n            }));\n        }\n    }\n    /**\n     * Watch and dynamically set attribute values, those values that are not\n     * props and are not pseudoProps\n     */\n    watchEffect(() => {\n        const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);\n        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n    });\n    /**\n     * Add any/all \"prop\" errors to the store.\n     */\n    watchEffect(() => {\n        const messages = props.errors.map((error) => createMessage({\n            key: slugify(error),\n            type: 'error',\n            value: error,\n            meta: { source: 'prop' },\n        }));\n        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');\n    });\n    /**\n     * Add input errors.\n     */\n    if (node.type !== 'input') {\n        const sourceKey = `${node.name}-prop`;\n        watchEffect(() => {\n            const keys = Object.keys(props.inputErrors);\n            if (!keys.length)\n                node.clearErrors(true, sourceKey);\n            const messages = keys.reduce((messages, key) => {\n                let value = props.inputErrors[key];\n                if (typeof value === 'string')\n                    value = [value];\n                if (Array.isArray(value)) {\n                    messages[key] = value.map((error) => createMessage({\n                        key: error,\n                        type: 'error',\n                        value: error,\n                        meta: { source: sourceKey },\n                    }));\n                }\n                return messages;\n            }, {});\n            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);\n        });\n    }\n    /**\n     * Watch the config prop for any changes.\n     */\n    watchEffect(() => Object.assign(node.config, props.config));\n    /**\n     * Produce another parent object.\n     */\n    if (node.type !== 'input') {\n        provide(parentSymbol, node);\n    }\n    let inputTimeout;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const mutex = new WeakSet();\n    /**\n     * Explicitly watch the input value, and emit changes (lazy)\n     */\n    node.on('modelUpdated', () => {\n        var _a, _b;\n        // Emit the values after commit\n        context.emit('inputRaw', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);\n        clearTimeout(inputTimeout);\n        inputTimeout = setTimeout(context.emit, 20, 'input', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);\n        if (isVModeled && node.context) {\n            const newValue = useRaw(node.context.value);\n            if (isObject(newValue) && useRaw(props.modelValue) !== newValue) {\n                // If this is an object that has been mutated inside FormKit core then\n                // we know when it is emitted it will \"return\" in the watchVerbose so\n                // we pro-actively add it to the mutex.\n                mutex.add(newValue);\n            }\n            context.emit('update:modelValue', newValue);\n        }\n    });\n    /**\n     * Enabled support for v-model, using this for groups/lists is not recommended\n     */\n    if (isVModeled) {\n        watchVerbose(toRef(props, 'modelValue'), (path, value) => {\n            var _a;\n            const rawValue = useRaw(value);\n            if (isObject(rawValue) && mutex.has(rawValue)) {\n                return mutex.delete(rawValue);\n            }\n            if (!path.length)\n                node.input(value, false);\n            else\n                (_a = node.at(path)) === null || _a === void 0 ? void 0 : _a.input(value, false);\n        });\n    }\n    /**\n     * When this input shuts down, we need to \"delete\" the node too.\n     */\n    onUnmounted(() => node.destroy());\n    return node;\n}\n\nlet totalCreated = 1;\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj) {\n    return ((typeof obj === 'function' && obj.length === 2) ||\n        (typeof obj === 'object' &&\n            !Array.isArray(obj) &&\n            !('$el' in obj) &&\n            !('$cmp' in obj) &&\n            !('if' in obj)));\n}\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input.\n * @public\n */\nfunction createInput(schemaOrComponent, definitionOptions = {}) {\n    const definition = {\n        type: 'input',\n        ...definitionOptions,\n    };\n    let schema;\n    if (isComponent(schemaOrComponent)) {\n        const cmpName = `SchemaComponent${totalCreated++}`;\n        schema = createSection('input', () => ({\n            $cmp: cmpName,\n            props: {\n                context: '$node.context',\n            },\n        }));\n        definition.library = { [cmpName]: markRaw(schemaOrComponent) };\n    }\n    else if (typeof schemaOrComponent === 'function') {\n        schema = schemaOrComponent;\n    }\n    else {\n        schema = createSection('input', () => cloneAny(schemaOrComponent));\n    }\n    // Use the default wrapping schema\n    definition.schema = useSchema(schema || 'Schema undefined');\n    return definition;\n}\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n * @param node - FormKitNode to create the context on.\n * @public\n */\nconst vueBindings = function vueBindings(node) {\n    /**\n     * Start a validity counter on all blocking messages.\n     */\n    node.ledger.count('blocking', (m) => m.blocking);\n    const isValid = ref(!node.ledger.value('blocking'));\n    /**\n     * Start an error message counter.\n     */\n    node.ledger.count('errors', (m) => m.type === 'error');\n    const hasErrors = ref(!!node.ledger.value('errors'));\n    /**\n     * Keep track of the first time a Vue tick cycle has passed.\n     */\n    let hasTicked = false;\n    nextTick(() => {\n        hasTicked = true;\n    });\n    /**\n     * All messages with the visibility state set to true.\n     */\n    const availableMessages = reactive(node.store.reduce((store, message) => {\n        if (message.visible) {\n            store[message.key] = message;\n        }\n        return store;\n    }, {}));\n    /**\n     * A flag that determines when validation messages should be displayed.\n     */\n    const validationVisibility = ref(node.props.validationVisibility || 'blur');\n    node.on('prop:validationVisibility', ({ payload }) => {\n        validationVisibility.value = payload;\n    });\n    /**\n     * Keep track of if this input has ever shown validation errors.\n     */\n    const hasShownErrors = ref(validationVisibility.value === 'live');\n    /**\n     * The current visibility state of validation messages.\n     */\n    const validationVisible = computed(() => {\n        if (context.state.submitted)\n            return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n            return false;\n        }\n        switch (validationVisibility.value) {\n            case 'live':\n                return true;\n            case 'blur':\n                return context.state.blurred;\n            case 'dirty':\n                return context.state.dirty;\n            default:\n                return false;\n        }\n    });\n    /**\n     * Determines if the input should be considered \"complete\".\n     */\n    const isComplete = computed(() => {\n        return hasValidation.value\n            ? isValid.value && !hasErrors.value\n            : context.state.dirty && !empty(context.value);\n    });\n    /**\n     * If the input has validation rules or not.\n     */\n    const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);\n    node.on('prop:parsedRules', ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n    });\n    /**\n     * All messages that are currently on display to an end user. This changes\n     * based on the current message type visibility, like errorVisibility.\n     */\n    const messages = computed(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n            const message = availableMessages[key];\n            if (message.type !== 'validation' || validationVisible.value) {\n                visibleMessages[key] = message;\n            }\n        }\n        return visibleMessages;\n    });\n    /**\n     * UI Messages.\n     */\n    const ui = reactive(node.store.reduce((messages, message) => {\n        if (message.type === 'ui' && message.visible)\n            messages[message.key] = message;\n        return messages;\n    }, {}));\n    /**\n     * This is the reactive data object that is provided to all schemas and\n     * forms. It is a subset of data in the core node object.\n     */\n    const cachedClasses = reactive({});\n    const classes = new Proxy(cachedClasses, {\n        get(...args) {\n            const [target, property] = args;\n            let className = Reflect.get(...args);\n            if (!className && typeof property === 'string') {\n                if (!has(target, property) && !property.startsWith('__v')) {\n                    const observedNode = createObserver(node);\n                    observedNode.watch((node) => {\n                        const rootClasses = typeof node.config.rootClasses === 'function'\n                            ? node.config.rootClasses(property, node)\n                            : {};\n                        const globalConfigClasses = node.config.classes\n                            ? createClasses(property, node, node.config.classes[property])\n                            : {};\n                        const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);\n                        const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);\n                        className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);\n                        target[property] = className;\n                    });\n                }\n            }\n            return className;\n        },\n    });\n    const describedBy = computed(() => {\n        const describers = [];\n        if (context.help) {\n            describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages.value) {\n            describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(' ') : undefined;\n    });\n    const value = ref(node.value);\n    const _value = ref(node.value);\n    const context = reactive({\n        _value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n            length: (obj) => Object.keys(obj).length,\n            number: (value) => Number(value),\n            string: (value) => String(value),\n            json: (value) => JSON.stringify(value),\n            eq,\n        },\n        handlers: {\n            blur: (e) => {\n                node.store.set(createMessage({ key: 'blurred', visible: false, value: true }));\n                if (typeof node.props.attrs.onBlur === 'function') {\n                    node.props.attrs.onBlur(e);\n                }\n            },\n            touch: () => {\n                node.store.set(createMessage({ key: 'dirty', visible: false, value: true }));\n            },\n            DOMInput: (e) => {\n                node.input(e.target.value);\n                node.emit('dom-input-event', e);\n            },\n        },\n        help: node.props.help,\n        id: node.props.id,\n        label: node.props.label,\n        messages,\n        node: markRaw(node),\n        options: node.props.options,\n        state: {\n            blurred: false,\n            complete: isComplete,\n            dirty: false,\n            submitted: false,\n            settled: node.isSettled,\n            valid: isValid,\n            errors: hasErrors,\n            rules: hasValidation,\n            validationVisible,\n        },\n        type: node.props.type,\n        ui,\n        value,\n        classes,\n    });\n    /**\n     * Ensure the context object is properly configured after booting up.\n     */\n    node.on('created', () => {\n        if (!eq(context.value, node.value)) {\n            _value.value = node.value;\n            value.value = node.value;\n            triggerRef(value);\n            triggerRef(_value);\n        }\n    });\n    /**\n     * Sets the settled state.\n     */\n    node.on('settled', ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n    });\n    /**\n     * Observes node.props properties explicitly and updates them in the context\n     * object.\n     * @param observe - Props to observe and register as context data.\n     */\n    function observeProps(observe) {\n        observe.forEach((prop) => {\n            prop = camel(prop);\n            if (!has(context, prop) && has(node.props, prop)) {\n                context[prop] = node.props[prop];\n            }\n            node.on(`prop:${prop}`, ({ payload }) => {\n                context[prop] = payload;\n            });\n        });\n    }\n    /**\n     * We use a node observer to individually observe node props.\n     */\n    const rootProps = () => {\n        const props = [\n            'help',\n            'label',\n            'disabled',\n            'options',\n            'type',\n            'attrs',\n            'preserve',\n            'preserveErrors',\n            'id',\n        ];\n        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;\n        const matchingProps = Object.keys(node.props).filter((prop) => {\n            return iconPattern.test(prop);\n        });\n        return props.concat(matchingProps);\n    };\n    observeProps(rootProps());\n    /**\n     * Once the input is defined, deal with it.\n     * @param definition - Type definition.\n     */\n    function definedAs(definition) {\n        if (definition.props)\n            observeProps(definition.props);\n    }\n    node.props.definition && definedAs(node.props.definition);\n    /**\n     * When new props are added to the core node as \"props\" (ie not attrs) then\n     * we automatically need to start tracking them here.\n     */\n    node.on('added-props', ({ payload }) => observeProps(payload));\n    /**\n     * Watch for input events from core.\n     */\n    node.on('input', ({ payload }) => {\n        _value.value = payload;\n        triggerRef(_value);\n    });\n    /**\n     * Watch for input commits from core.\n     */\n    node.on('commit', ({ payload }) => {\n        value.value = _value.value = payload;\n        triggerRef(value);\n        node.emit('modelUpdated');\n        // The input is dirty after a value has been input by a user\n        if (!context.state.dirty && node.isCreated && hasTicked)\n            context.handlers.touch();\n        if (isComplete &&\n            node.type === 'input' &&\n            hasErrors.value &&\n            !undefine(node.props.preserveErrors)) {\n            node.store.filter((message) => { var _a; return !(message.type === 'error' && ((_a = message.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true); });\n        }\n    });\n    /**\n     * Update the local state in response to messages.\n     * @param message - A formkit message\n     */\n    const updateState = async (message) => {\n        if (message.type === 'ui' &&\n            message.visible &&\n            !message.meta.showAsMessage) {\n            ui[message.key] = message;\n        }\n        else if (message.visible) {\n            availableMessages[message.key] = message;\n        }\n        else if (message.type === 'state') {\n            // await node.settled\n            context.state[message.key] = !!message.value;\n        }\n    };\n    /**\n     * Listen to message events and modify the local message data values.\n     */\n    node.on('message-added', (e) => updateState(e.payload));\n    node.on('message-updated', (e) => updateState(e.payload));\n    node.on('message-removed', ({ payload: message }) => {\n        delete ui[message.key];\n        delete availableMessages[message.key];\n        delete context.state[message.key];\n    });\n    node.on('settled:blocking', () => {\n        isValid.value = true;\n    });\n    node.on('unsettled:blocking', () => {\n        isValid.value = false;\n    });\n    node.on('settled:errors', () => {\n        hasErrors.value = false;\n    });\n    node.on('unsettled:errors', () => {\n        hasErrors.value = true;\n    });\n    /**\n     * Watch the validation visible prop and set the hasShownErrors state.\n     */\n    watch(validationVisible, (value) => {\n        if (value) {\n            hasShownErrors.value = true;\n        }\n    });\n    node.context = context;\n    // The context is complete\n    node.emit('context', node, false);\n};\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n * @public\n */\nconst defaultConfig = (options = {}) => {\n    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, theme = undefined, iconLoaderUrl = undefined, iconLoader = undefined, icons = {}, ...nodeOptions } = options;\n    /**\n     * The default configuration includes the validation plugin,\n     * with all core-available validation rules.\n     */\n    const validation = createValidationPlugin({\n        ...defaultRules,\n        ...(rules || {}),\n    });\n    /**\n     * Includes the i18n plugin with only the english language\n     * messages.\n     */\n    const i18n = createI18nPlugin(extend({ en, ...(locales || {}) }, messages));\n    /**\n     * Create the library of inputs that are generally available. This default\n     * config imports all \"native\" inputs by default, but\n     */\n    const library = createLibraryPlugin(inputs, inputs$1);\n    /**\n     * Create the theme plugin for the user provided theme\n     */\n    const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);\n    return extend({\n        plugins: [library, themePlugin, vueBindings, i18n, validation],\n        ...(!locale ? {} : { config: { locale } }),\n    }, nodeOptions || {}, true);\n};\n\n/**\n * Renders an icon using the current IconLoader set at the root FormKit config\n * @public\n */\nconst FormKitIcon = defineComponent({\n    props: {\n        icon: {\n            type: String,\n            default: ''\n        },\n        iconLoader: {\n            type: Function,\n            default: null\n        },\n        iconLoaderUrl: {\n            type: Function,\n            default: null\n        }\n    },\n    setup(props) {\n        var _a, _b;\n        const icon = ref(undefined);\n        const config = inject(optionsSymbol, {});\n        const parent = inject(parentSymbol, null);\n        let iconHandler = undefined;\n        if (props.iconLoader && typeof props.iconLoader === 'function') {\n            // if we have a locally supplied loader, then use it\n            iconHandler = createIconHandler(props.iconLoader);\n        }\n        else if (parent && ((_a = parent.props) === null || _a === void 0 ? void 0 : _a.iconLoader)) {\n            // otherwise try to inherit from a parent\n            iconHandler = createIconHandler(parent.props.iconLoader);\n        }\n        else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === 'function') {\n            iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);\n        }\n        else {\n            // grab our iconHandler from the global config\n            const iconPlugin = (_b = config === null || config === void 0 ? void 0 : config.plugins) === null || _b === void 0 ? void 0 : _b.find(plugin => {\n                return typeof plugin.iconHandler === 'function';\n            });\n            if (iconPlugin) {\n                iconHandler = iconPlugin.iconHandler;\n            }\n        }\n        if (iconHandler && typeof iconHandler === 'function') {\n            const iconOrPromise = iconHandler(props.icon);\n            if (iconOrPromise instanceof Promise) {\n                iconOrPromise.then((iconValue) => {\n                    icon.value = iconValue;\n                });\n            }\n            else {\n                icon.value = iconOrPromise;\n            }\n        }\n        return () => {\n            if (icon.value) {\n                return h('span', {\n                    class: 'formkit-icon',\n                    innerHTML: icon.value\n                });\n            }\n            return null;\n        };\n    }\n});\n\nexport { FormKit, FormKitIcon, FormKitSchema, vueBindings as bindings, configSymbol, createInput, defaultConfig, optionsSymbol, parentSymbol, plugin, useInput, watchVerbose };\n"],
  "mappings": "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",
  "names": []
}
